Branch Summary for 'group-circle'

Detailed Code Changes:
------------------------------------
Commit: 8b0864c3bf9770d506e815c5d594f4fd2156ac4f
------------------------------------
commit 8b0864c3bf9770d506e815c5d594f4fd2156ac4f
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Wed May 22 12:27:29 2024 +0100

    experimenting with max speed

 config/config.json | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)
diff --git a/config/config.json b/config/config.json
index 5a877dc..65175dd 100644
--- a/config/config.json
+++ b/config/config.json
@@ -16,9 +16,9 @@
   "MAX_TIME": 10000,
   "NUM_ROBOTS": 20,
   "T_HORIZON": 10,
-  "ROBOT_RADIUS": 1,
+  "ROBOT_RADIUS": 0.5,
   "COMMUNICATION_RADIUS": 20,
-  "MAX_SPEED": 2,
+  "MAX_SPEED": 5,
   "COMMS_FAILURE_RATE": 0,
   "FORMATION": "circle",
   "OBSTACLE_FILE": "",
@@ -29,5 +29,4 @@
   "SIGMA_FACTOR_OBSTACLE": 0.01,
   "SIGMA_FACTOR_MASTERSLAVE": 1,
   "NUM_ITERS": 10
-
 }
\ No newline at end of file

Commit: ec6d7f89016f8326cf3b562f551994617500e7c6
------------------------------------
commit ec6d7f89016f8326cf3b562f551994617500e7c6
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Fri May 10 17:41:39 2024 +0100

    Hard limited the h value to prevent excess energy, this seems to have solved the issue of distant spawning dots but is only a temporary fix. Main issue still needs to be identified. Theory is that they are basing energy off of x0 y0.

 .vscode/launch.json     | 17 -----------------
 .vscode/tasks.json      | 29 -----------------------------
 config/config.json      |  4 ++--
 inc/gbp/GBPCore.h       |  4 ++--
 src/gbp/Factor.cpp      | 10 ++++++++++
 src/gbp/Factorgraph.cpp |  4 ++--
 6 files changed, 16 insertions(+), 52 deletions(-)
diff --git a/.vscode/launch.json b/.vscode/launch.json
index ed42005..e69de29 100644
--- a/.vscode/launch.json
+++ b/.vscode/launch.json
@@ -1,17 +0,0 @@
-{
-    "version": "0.2.0",
-    "configurations": [
-        {
-            "name": "(lldb) Launch",
-            "type": "cppdbg",
-            "request": "launch",
-            "program": "${workspaceFolder}/build/gbpplanner",
-            "args": ["--cfg", "../config/circle_cluttered.json"],
-            "stopAtEntry": false,
-            "cwd": "${workspaceFolder}",
-            "environment": [],
-            "externalConsole": false,
-            "MIMode": "lldb",
-        }
-    ]
-}
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
index c5f9098..e69de29 100644
--- a/.vscode/tasks.json
+++ b/.vscode/tasks.json
@@ -1,29 +0,0 @@
-{
-    "tasks": [
-        {
-            "type": "cppbuild",
-            "label": "C/C++: clang++ build active file",
-            "command": "/opt/homebrew/opt/llvm/bin/clang++",
-            "args": [
-                "-fcolor-diagnostics",
-                "-fansi-escape-codes",
-                "-g",
-                "${file}",
-                "-o",
-                "${fileDirname}/${fileBasenameNoExtension}"
-            ],
-            "options": {
-                "cwd": "${fileDirname}"
-            },
-            "problemMatcher": [
-                "$gcc"
-            ],
-            "group": {
-                "kind": "build",
-                "isDefault": true
-            },
-            "detail": "Task generated by Debugger."
-        }
-    ],
-    "version": "2.0.0"
-}
\ No newline at end of file
diff --git a/config/config.json b/config/config.json
index 30d675e..5a877dc 100644
--- a/config/config.json
+++ b/config/config.json
@@ -14,7 +14,7 @@
   "SEED": 2,
   "TIMESTEP": 0.1,
   "MAX_TIME": 10000,
-  "NUM_ROBOTS": 8,
+  "NUM_ROBOTS": 20,
   "T_HORIZON": 10,
   "ROBOT_RADIUS": 1,
   "COMMUNICATION_RADIUS": 20,
@@ -27,7 +27,7 @@
   "SIGMA_FACTOR_DYNAMICS": 0.1,
   "SIGMA_FACTOR_INTERROBOT": 0.01,
   "SIGMA_FACTOR_OBSTACLE": 0.01,
-  "SIGMA_FACTOR_MASTERSLAVE": 0.6,
+  "SIGMA_FACTOR_MASTERSLAVE": 1,
   "NUM_ITERS": 10
 
 }
\ No newline at end of file
diff --git a/inc/gbp/GBPCore.h b/inc/gbp/GBPCore.h
index e73d0ee..bc8e2cf 100644
--- a/inc/gbp/GBPCore.h
+++ b/inc/gbp/GBPCore.h
@@ -35,7 +35,7 @@ void iterateGBP(int n_iters, MsgPassingMode msg_passing_mode, std::map<int, std:
 {
     for (int i = 0; i < n_iters; i++)
     {
-        // #pragma omp parallel for
+#pragma omp parallel for
         // Iterate through robots
         for (int r_idx = 0; r_idx < factorgraphs.size(); r_idx++)
         {
@@ -45,7 +45,7 @@ void iterateGBP(int n_iters, MsgPassingMode msg_passing_mode, std::map<int, std:
             factorgraph->factorIteration(msg_passing_mode);
         }
 
-        // #pragma omp parallel for
+#pragma omp parallel for
         // Iterate through robots
         for (int r_idx = 0; r_idx < factorgraphs.size(); r_idx++)
         {
diff --git a/src/gbp/Factor.cpp b/src/gbp/Factor.cpp
index 04f47e9..af852fe 100644
--- a/src/gbp/Factor.cpp
+++ b/src/gbp/Factor.cpp
@@ -332,6 +332,7 @@ Eigen::MatrixXd ObstacleFactor::h_func_(const Eigen::VectorXd &X)
 // within a certain distance from the master robot. The factor has 0 energy if the slave robot is within the specified distance.
 /********************************************************************************************/
 
+int temp = 0;
 MasterSlaveFactor::MasterSlaveFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
                                      float sigma, const Eigen::VectorXd &measurement)
     : Factor(f_id, r_id, variables, sigma, measurement)
@@ -343,12 +344,21 @@ Eigen::MatrixXd MasterSlaveFactor::h_func_(const Eigen::VectorXd &X)
 {
     Eigen::MatrixXd h = Eigen::MatrixXd::Zero(1, 1);
     h(0) = (X({0, 1}) - X({4, 5})).norm();
+    if (h(0) > 20)
+        h(0) = 20;
+    // if (r_id_ == 3 and temp < 1000)
+    // {
+    //     temp += 1;
+    //     printf("h: %f, x: %f, y: %f\n", h(0), X(0), X(1));
+    // }
     return h;
 }
 
 Eigen::MatrixXd MasterSlaveFactor::J_func_(const Eigen::VectorXd &X)
 {
     Eigen::MatrixXd J = jacobianFirstOrder(X);
+    // J.col(0) = Eigen::VectorXd::Zero(1);
+    // J.col(1) = Eigen::VectorXd::Zero(1);
     J.col(4) = Eigen::VectorXd::Zero(1);
     J.col(5) = Eigen::VectorXd::Zero(1);
     return J;
diff --git a/src/gbp/Factorgraph.cpp b/src/gbp/Factorgraph.cpp
index ab33871..9d10483 100644
--- a/src/gbp/Factorgraph.cpp
+++ b/src/gbp/Factorgraph.cpp
@@ -26,7 +26,7 @@ FactorGraph::FactorGraph(int robot_id) : robot_id_(robot_id){};
 /******************************************************************************************************/
 void FactorGraph::factorIteration(MsgPassingMode msg_passing_mode)
 {
-    // #pragma omp parallel for
+#pragma omp parallel for
     for (int f_idx = 0; f_idx < factors_.size(); f_idx++)
     {
         auto f_it = factors_.begin();
@@ -62,7 +62,7 @@ void FactorGraph::factorIteration(MsgPassingMode msg_passing_mode)
 /******************************************************************************************************/
 void FactorGraph::variableIteration(MsgPassingMode msg_passing_mode)
 {
-    // #pragma omp parallel for
+#pragma omp parallel for
     for (int v_idx = 0; v_idx < variables_.size(); v_idx++)
     {
         auto v_it = variables_.begin();

Commit: e8ef048ededf510285e819faa400bdbc792a73f1
------------------------------------
commit e8ef048ededf510285e819faa400bdbc792a73f1
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Fri May 10 12:28:08 2024 +0100

    correction to previous. anything above 6 robots does not work , it does not follow the same pattern

 config/config.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
diff --git a/config/config.json b/config/config.json
index 73d4362..30d675e 100644
--- a/config/config.json
+++ b/config/config.json
@@ -14,7 +14,7 @@
   "SEED": 2,
   "TIMESTEP": 0.1,
   "MAX_TIME": 10000,
-  "NUM_ROBOTS": 6,
+  "NUM_ROBOTS": 8,
   "T_HORIZON": 10,
   "ROBOT_RADIUS": 1,
   "COMMUNICATION_RADIUS": 20,

Commit: 83b8997c4cf62121cb6268be66aec460b6496279
------------------------------------
commit 83b8997c4cf62121cb6268be66aec460b6496279
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Fri May 10 12:26:05 2024 +0100

    Latest experimentation seems to show that the number of robots is directly tied to the SIGMA_FACTOR_MASTERSLAVE. so if ther number of robots is 2 then sigma can be 1 if 4 then sigma needs to be 0.8 if 6 then sigma 0.6 and so on

 config/config.json | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
diff --git a/config/config.json b/config/config.json
index 1fd70cd..73d4362 100644
--- a/config/config.json
+++ b/config/config.json
@@ -14,7 +14,7 @@
   "SEED": 2,
   "TIMESTEP": 0.1,
   "MAX_TIME": 10000,
-  "NUM_ROBOTS": 4,
+  "NUM_ROBOTS": 6,
   "T_HORIZON": 10,
   "ROBOT_RADIUS": 1,
   "COMMUNICATION_RADIUS": 20,
@@ -27,7 +27,7 @@
   "SIGMA_FACTOR_DYNAMICS": 0.1,
   "SIGMA_FACTOR_INTERROBOT": 0.01,
   "SIGMA_FACTOR_OBSTACLE": 0.01,
-  "SIGMA_FACTOR_MASTERSLAVE": 1,
+  "SIGMA_FACTOR_MASTERSLAVE": 0.6,
   "NUM_ITERS": 10
 
 }
\ No newline at end of file

Commit: 3c324513abf12b4df636487ce382884265ca0ee0
------------------------------------
commit 3c324513abf12b4df636487ce382884265ca0ee0
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Fri May 10 12:24:05 2024 +0100

    convoy working for 2 robots

 config/config.json      |   3 +-
 inc/gbp/Factor.h        |  11 ++---
 inc/gbp/GBPCore.h       | 116 ++++++++++++++++++++++++++++++++----------------
 src/Robot.cpp           |  31 ++++++-------
 src/Simulator.cpp       |   8 ++--
 src/gbp/Factor.cpp      |  36 +++++----------
 src/gbp/Factorgraph.cpp |  47 ++++++++++++--------
 7 files changed, 141 insertions(+), 111 deletions(-)
diff --git a/config/config.json b/config/config.json
index a12e6a8..1fd70cd 100644
--- a/config/config.json
+++ b/config/config.json
@@ -14,7 +14,7 @@
   "SEED": 2,
   "TIMESTEP": 0.1,
   "MAX_TIME": 10000,
-  "NUM_ROBOTS": 20,
+  "NUM_ROBOTS": 4,
   "T_HORIZON": 10,
   "ROBOT_RADIUS": 1,
   "COMMUNICATION_RADIUS": 20,
@@ -27,6 +27,7 @@
   "SIGMA_FACTOR_DYNAMICS": 0.1,
   "SIGMA_FACTOR_INTERROBOT": 0.01,
   "SIGMA_FACTOR_OBSTACLE": 0.01,
+  "SIGMA_FACTOR_MASTERSLAVE": 1,
   "NUM_ITERS": 10
 
 }
\ No newline at end of file
diff --git a/inc/gbp/Factor.h b/inc/gbp/Factor.h
index ec3a1b5..268b078 100644
--- a/inc/gbp/Factor.h
+++ b/inc/gbp/Factor.h
@@ -147,13 +147,8 @@ class MasterSlaveFactor : public Factor
 {
 public:
     MasterSlaveFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-                      float sigma, const Eigen::VectorXd &measurement,
-                      std::shared_ptr<Robot> robot, std::shared_ptr<Robot> master_robot);
+                      float sigma, const Eigen::VectorXd &measurement);
 
-    Eigen::MatrixXd h_func_(const Eigen::VectorXd &X) override;
-    // Eigen::MatrixXd J_func_(const Eigen::VectorXd &X) override;
-
-private:
-    std::shared_ptr<Robot> robot_;
-    std::shared_ptr<Robot> master_;
+    Eigen::MatrixXd h_func_(const Eigen::VectorXd &X);
+    Eigen::MatrixXd J_func_(const Eigen::VectorXd &X);
 };
\ No newline at end of file
diff --git a/inc/gbp/GBPCore.h b/inc/gbp/GBPCore.h
index c801348..e73d0ee 100644
--- a/inc/gbp/GBPCore.h
+++ b/inc/gbp/GBPCore.h
@@ -2,7 +2,7 @@
 // Copyright (c) 2023 Aalok Patwardhan (a.patwardhan21@imperial.ac.uk)
 // This code is licensed (see LICENSE for details)
 /**************************************************************************************/
-#pragma once 
+#pragma once
 #include <memory>
 #include <map>
 #include <vector>
@@ -17,62 +17,74 @@ extern Globals globals;
 // This file contains the core algorithm of Gaussian Belief Propagation
 /*************************************************************************************************************/
 // Message passing can be done within a robot/factorgraph (INTERNAL) or between two different robots/factorgraphs (EXTERNAL)
-enum MsgPassingMode {EXTERNAL, INTERNAL};
+enum MsgPassingMode
+{
+    EXTERNAL,
+    INTERNAL
+};
 
 /***********************************************************************************/
 // iterateGBP performs n_iters iterations of message passing of the given message passing mode, on the set of
 // factorgraphs provided in factorgraphs. Note, these are in a map, accesed by an int. These could be the map of simulator->robots_.
 /***********************************************************************************/
 template <typename T>
-void iterateGBP(int n_iters, MsgPassingMode msg_passing_mode, std::map<int, std::shared_ptr<T>>& factorgraphs);
+void iterateGBP(int n_iters, MsgPassingMode msg_passing_mode, std::map<int, std::shared_ptr<T>> &factorgraphs);
 
 template <typename T>
-void iterateGBP(int n_iters, MsgPassingMode msg_passing_mode, std::map<int, std::shared_ptr<T>>& factorgraphs){
-    for (int i=0; i<n_iters; i++){
-#pragma omp parallel for
+void iterateGBP(int n_iters, MsgPassingMode msg_passing_mode, std::map<int, std::shared_ptr<T>> &factorgraphs)
+{
+    for (int i = 0; i < n_iters; i++)
+    {
+        // #pragma omp parallel for
         // Iterate through robots
-        for (int r_idx=0; r_idx<factorgraphs.size(); r_idx++){
-            auto it_r = factorgraphs.begin(); std::advance(it_r, r_idx);
-            auto& [r_id, factorgraph] = *it_r;
+        for (int r_idx = 0; r_idx < factorgraphs.size(); r_idx++)
+        {
+            auto it_r = factorgraphs.begin();
+            std::advance(it_r, r_idx);
+            auto &[r_id, factorgraph] = *it_r;
             factorgraph->factorIteration(msg_passing_mode);
         }
-    
-#pragma omp parallel for
+
+        // #pragma omp parallel for
         // Iterate through robots
-        for (int r_idx=0; r_idx<factorgraphs.size(); r_idx++){
-            auto it_r = factorgraphs.begin(); std::advance(it_r, r_idx);
-            auto& [r_id, factorgraph] = *it_r;
+        for (int r_idx = 0; r_idx < factorgraphs.size(); r_idx++)
+        {
+            auto it_r = factorgraphs.begin();
+            std::advance(it_r, r_idx);
+            auto &[r_id, factorgraph] = *it_r;
             factorgraph->variableIteration(msg_passing_mode);
         }
     }
-
-}    
-
+}
 
 /******************************************************************/
 // This data structure is used to represent both variables and factors
 // it includes the id of the robot that the variable/factor belongs to, as well as its own id
 // The given operators allow for searching and comparisons using the Key structure
 /******************************************************************/
-class Key {
-    public:
+class Key
+{
+public:
     int robot_id_;
     int node_id_;
     bool valid_;
-    
-    Key(int graph_id, int node_id, bool valid=true)
+
+    Key(int graph_id, int node_id, bool valid = true)
         : robot_id_(graph_id), node_id_(node_id), valid_(valid) {}
 
-    friend bool operator== (const Key &key1, const Key &key2) {
+    friend bool operator==(const Key &key1, const Key &key2)
+    {
         return key1.robot_id_ == key2.robot_id_ && key1.node_id_ == key2.node_id_;
     }
-    friend bool operator!= (const Key &key1, const Key &key2) {
+    friend bool operator!=(const Key &key1, const Key &key2)
+    {
         return !(key1.robot_id_ == key2.robot_id_ && key1.node_id_ == key2.node_id_);
     }
 
-    friend bool operator< (const Key &key1, const Key &key2) {
+    friend bool operator<(const Key &key1, const Key &key2)
+    {
         return (key1.robot_id_ < key2.robot_id_) ||
-            (key1.robot_id_ == key2.robot_id_ && key1.node_id_ < key2.node_id_);
+               (key1.robot_id_ == key2.robot_id_ && key1.node_id_ < key2.node_id_);
     }
 };
 
@@ -82,40 +94,68 @@ class Key {
 // Traditionally GBP does not require the sending of the last parameter mu (the mean), as it
 // can be calculated from the eta and lambda. We include it here for computational efficiency.
 /******************************************************************/
-class Message {
-    public:
+class Message
+{
+public:
     Eigen::VectorXd eta;
     Eigen::MatrixXd lambda;
     Eigen::VectorXd mu;
 
     // A Message can be initialised with zeros, of the dimension given in the input.
-    Message(int n=globals.N_DOFS){
+    Message(int n = globals.N_DOFS)
+    {
         eta = Eigen::VectorXd::Zero(n);
         lambda = Eigen::MatrixXd::Zero(n, n);
         mu = Eigen::VectorXd::Zero(n);
     }
     // A message can also be initialised explicitly using a given eta, lambda and optionally mu.
-    Message(Eigen::VectorXd eta_in, Eigen::MatrixXd lambda_in, Eigen::VectorXd mu_in = Eigen::VectorXd::Zero(globals.N_DOFS)){
+    Message(Eigen::VectorXd eta_in, Eigen::MatrixXd lambda_in, Eigen::VectorXd mu_in = Eigen::VectorXd::Zero(globals.N_DOFS))
+    {
         int n = eta_in.rows();
         eta = eta_in;
         lambda = lambda_in;
-        mu = (mu_in.rows()==n) ? mu_in : Eigen::VectorXd::Zero(n);
+        mu = (mu_in.rows() == n) ? mu_in : Eigen::VectorXd::Zero(n);
     }
-    
+
     // These operators allow for calculations to be done with Messages, eg. Adding and Subtracting.
     // Note, during addition and subtraction, the mean vector mu is untouched.
-    Message& operator+=(const Message& msg_to_add) {eta += msg_to_add.eta; lambda += msg_to_add.lambda; return *this;};
-    Message& operator-=(const Message& msg_to_add) {eta -= msg_to_add.eta; lambda -= msg_to_add.lambda; return *this;};
-    const Message operator+(const Message& msg_to_add) const {Message ret_msg = *this; ret_msg += msg_to_add; return ret_msg;};
-    const Message operator-(const Message& msg_to_sub) const {Message ret_msg = *this; ret_msg -= msg_to_sub; return ret_msg;};
-    
+    Message &operator+=(const Message &msg_to_add)
+    {
+        eta += msg_to_add.eta;
+        lambda += msg_to_add.lambda;
+        return *this;
+    };
+    Message &operator-=(const Message &msg_to_add)
+    {
+        eta -= msg_to_add.eta;
+        lambda -= msg_to_add.lambda;
+        return *this;
+    };
+    const Message operator+(const Message &msg_to_add) const
+    {
+        Message ret_msg = *this;
+        ret_msg += msg_to_add;
+        return ret_msg;
+    };
+    const Message operator-(const Message &msg_to_sub) const
+    {
+        Message ret_msg = *this;
+        ret_msg -= msg_to_sub;
+        return ret_msg;
+    };
+
     // This function sets the message to zero. mu is untouched.
-    void setZero(){
+    void setZero()
+    {
         eta.setZero();
         lambda.setZero();
     }
     // This function sets the mean vector (mu) to a desired value.
-    Message& setMu(Eigen::VectorXd mu_in) {this->mu = mu_in; return *this;};
+    Message &setMu(Eigen::VectorXd mu_in)
+    {
+        this->mu = mu_in;
+        return *this;
+    };
 };
 
 // This is the data structure representing a mailbox of Messages, that can be accessed by a Key.
diff --git a/src/Robot.cpp b/src/Robot.cpp
index aaf06f1..25f3f1a 100644
--- a/src/Robot.cpp
+++ b/src/Robot.cpp
@@ -307,25 +307,22 @@ Eigen::VectorXd Robot::getPosition() const
 /***************************************************************************************************/
 void Robot::createMasterSlaveFactors()
 {
-    if (!this->isMaster_ && sim_->robots_.count(master_id_))
-    { // Check if it's a slave and master exists
-        std::shared_ptr<Robot> master_robot = sim_->robots_.at(master_id_);
-        // Create MasterSlave factors for all timesteps excluding current state
-        for (int i = 1; i < num_variables_; i++)
-        {
-            // Get variables
-            std::vector<std::shared_ptr<Variable>> variables{getVar(i), master_robot->getVar(i)};
+    std::shared_ptr<Robot> master_robot = sim_->robots_.at(master_id_);
+    // Create MasterSlave factors for all timesteps excluding current state
+    for (int i = 1; i < num_variables_; i++)
+    {
+        // Get variables
+        std::vector<std::shared_ptr<Variable>> variables{getVar(i), master_robot->getVar(i)};
 
-            // Create the master-slave factor
-            Eigen::VectorXd z = Eigen::VectorXd::Zero(variables.front()->n_dofs_);
+        // Create the master-slave factor
+        Eigen::VectorXd z = Eigen::VectorXd::Zero(1);
 
-            auto factor = std::make_shared<MasterSlaveFactor>(sim_->next_fid_++, this->rid_, variables, globals.SIGMA_FACTOR_MASTERSLAVE, z, shared_from_this(), master_robot);
-            factor->other_rid_ = master_robot->rid_;
+        auto factor = std::make_shared<MasterSlaveFactor>(sim_->next_fid_++, this->rid_, variables, globals.SIGMA_FACTOR_MASTERSLAVE, z);
+        factor->other_rid_ = master_robot->rid_;
 
-            // Add factor to the variable's list of factors, as well as to the robot's list of factors
-            for (auto var : factor->variables_)
-                var->add_factor(factor);
-            this->factors_[factor->key_] = factor;
-        }
+        // Add factor to the variable's list of factors, as well as to the robot's list of factors
+        for (auto var : factor->variables_)
+            var->add_factor(factor);
+        this->factors_[factor->key_] = factor;
     }
 }
\ No newline at end of file
diff --git a/src/Simulator.cpp b/src/Simulator.cpp
index e51e033..e3a73c1 100644
--- a/src/Simulator.cpp
+++ b/src/Simulator.cpp
@@ -76,12 +76,13 @@ void Simulator::draw()
                 // Cast positions to float explicitly
                 Vector3 slave_position = {
                     static_cast<float>(robot->position_(0)),
-                    static_cast<float>(robot->position_(2)),
+                    static_cast<float>(robot->height_3D_),
                     static_cast<float>(robot->position_(1))};
                 Vector3 master_position = {
                     static_cast<float>(master_robot->second->position_(0)),
-                    static_cast<float>(master_robot->second->position_(2)),
+                    static_cast<float>(master_robot->second->height_3D_),
                     static_cast<float>(master_robot->second->position_(1))};
+                // print(rid, robot->position_.transpose().eval(), master_robot->second->position_.transpose().eval());
                 DrawLine3D(slave_position, master_position, DARKGRAY);
             }
         }
@@ -415,7 +416,8 @@ void Simulator::createOrDeleteRobots()
     {
         robot_positions_[robot->rid_] = std::vector<double>{robot->waypoints_[0](0), robot->waypoints_[0](1)};
         robots_[robot->rid_] = robot;
-        robot->createMasterSlaveFactors();
+        if (!robot->isMaster_)
+            robot->createMasterSlaveFactors();
     };
     for (auto robot : robots_to_delete)
     {
diff --git a/src/gbp/Factor.cpp b/src/gbp/Factor.cpp
index fba9394..04f47e9 100644
--- a/src/gbp/Factor.cpp
+++ b/src/gbp/Factor.cpp
@@ -333,39 +333,23 @@ Eigen::MatrixXd ObstacleFactor::h_func_(const Eigen::VectorXd &X)
 /********************************************************************************************/
 
 MasterSlaveFactor::MasterSlaveFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-                                     float sigma, const Eigen::VectorXd &measurement,
-                                     std::shared_ptr<Robot> robot, std::shared_ptr<Robot> master_robot)
-    : Factor(f_id, r_id, variables, sigma, measurement), robot_(robot), master_(master_robot)
+                                     float sigma, const Eigen::VectorXd &measurement)
+    : Factor(f_id, r_id, variables, sigma, measurement)
 {
-    printf("MasterSlaveFactor created for robot %d connected to master %d\n", r_id, master_robot->rid_);
     factor_type_ = MASTER_SLAVE_FACTOR;
 }
 
 Eigen::MatrixXd MasterSlaveFactor::h_func_(const Eigen::VectorXd &X)
 {
     Eigen::MatrixXd h = Eigen::MatrixXd::Zero(1, 1);
-    if (master_)
-    {
-        Eigen::VectorXd masterPos = master_->getPosition();
-        Eigen::VectorXd robotPos = robot_->getPosition();
-        printf("Robot %d at [%f, %f] connected to master %d at [%f, %f]\n", robot_->rid_, robotPos(0), robotPos(1), master_->rid_, masterPos(0), masterPos(1));
-        h(0) = (masterPos - robotPos).norm(); // Directly calculate Euclidean distance
-    }
+    h(0) = (X({0, 1}) - X({4, 5})).norm();
     return h;
 }
 
-// Eigen::MatrixXd MasterSlaveFactor::J_func_(const Eigen::VectorXd &X)
-// {
-//     Eigen::MatrixXd J = Eigen::MatrixXd::Zero(1, robot_->getPosition().size());
-//     if (master_)
-//     {
-//         Eigen::VectorXd masterPos = master_->getPosition();
-//         Eigen::VectorXd robotPos = robot_->getPosition();
-//         double dist = (masterPos - robotPos).norm();
-//         if (dist > 0)
-//         { // Prevent division by zero
-//             J.row(0) = (robotPos - masterPos) / dist;
-//         }
-//     }
-//     return J;
-// }
\ No newline at end of file
+Eigen::MatrixXd MasterSlaveFactor::J_func_(const Eigen::VectorXd &X)
+{
+    Eigen::MatrixXd J = jacobianFirstOrder(X);
+    J.col(4) = Eigen::VectorXd::Zero(1);
+    J.col(5) = Eigen::VectorXd::Zero(1);
+    return J;
+}
\ No newline at end of file
diff --git a/src/gbp/Factorgraph.cpp b/src/gbp/Factorgraph.cpp
index 72f3adc..ab33871 100644
--- a/src/gbp/Factorgraph.cpp
+++ b/src/gbp/Factorgraph.cpp
@@ -19,21 +19,26 @@ FactorGraph::FactorGraph(int robot_id) : robot_id_(robot_id){};
 //
 //  * Note: we deal with cases where the variable/factor iteration may need to be skipped:
 //      - communications failure modes:
-//          if interrobot_comms_active_ is false, variables and factors connected to 
+//          if interrobot_comms_active_ is false, variables and factors connected to
 //          other robots should not take part in GBP iterations,
 //      - message passing modes (INTERNAL within a robot's own factorgraph or EXTERNAL between a robot and other robots):
 //          in which case the variable or factor may or may not need to take part in GBP depending on if it's connected to another robot
 /******************************************************************************************************/
-void FactorGraph::factorIteration(MsgPassingMode msg_passing_mode){
-#pragma omp parallel for    
-    for (int f_idx=0; f_idx<factors_.size(); f_idx++){
-        auto f_it = factors_.begin(); std::advance(f_it, f_idx);
+void FactorGraph::factorIteration(MsgPassingMode msg_passing_mode)
+{
+    // #pragma omp parallel for
+    for (int f_idx = 0; f_idx < factors_.size(); f_idx++)
+    {
+        auto f_it = factors_.begin();
+        std::advance(f_it, f_idx);
         auto [f_key, fac] = *f_it;
 
-        for (auto var : fac->variables_){
+        for (auto var : fac->variables_)
+        {
             // Check if the factor need to be skipped [see note in description]
-            if (((msg_passing_mode==INTERNAL) == (var->key_.robot_id_!=robot_id_) ||
-                    (!interrobot_comms_active_ && (var->key_.robot_id_!=robot_id_) && (msg_passing_mode==EXTERNAL)))) continue;
+            if (((msg_passing_mode == INTERNAL) == (var->key_.robot_id_ != robot_id_) ||
+                 (!interrobot_comms_active_ && (var->key_.robot_id_ != robot_id_) && (msg_passing_mode == EXTERNAL))))
+                continue;
             // Read message from each connected variable
             fac->inbox_[var->key_] = var->outbox_.at(f_key);
         }
@@ -50,22 +55,27 @@ void FactorGraph::factorIteration(MsgPassingMode msg_passing_mode){
 //
 //  * Note: we deal with cases where the variable/factor iteration may need to be skipped:
 //      - communications failure modes:
-//          if interrobot_comms_active_ is false, variables and factors connected to 
+//          if interrobot_comms_active_ is false, variables and factors connected to
 //          other robots should not take part in GBP iterations,
 //      - message passing modes (INTERNAL within a robot's own factorgraph or EXTERNAL between a robot and other robots):
 //          in which case the variable or factor may or may not need to take part in GBP depending on if it's connected to another robot
 /******************************************************************************************************/
-void FactorGraph::variableIteration(MsgPassingMode msg_passing_mode){
-#pragma omp parallel for    
-    for (int v_idx=0; v_idx<variables_.size(); v_idx++){
-        auto v_it = variables_.begin(); std::advance(v_it, v_idx);
+void FactorGraph::variableIteration(MsgPassingMode msg_passing_mode)
+{
+    // #pragma omp parallel for
+    for (int v_idx = 0; v_idx < variables_.size(); v_idx++)
+    {
+        auto v_it = variables_.begin();
+        std::advance(v_it, v_idx);
         auto [v_key, var] = *v_it;
 
-        for (auto [f_key, fac] : var->factors_){
+        for (auto [f_key, fac] : var->factors_)
+        {
             // * Check if the variable need to be skipped [see note in description]
-            if (((msg_passing_mode==INTERNAL) == (var->key_.robot_id_!=robot_id_) ||
-                    (!interrobot_comms_active_ && (var->key_.robot_id_!=robot_id_) && (msg_passing_mode==EXTERNAL)))) continue;
-            
+            if (((msg_passing_mode == INTERNAL) == (var->key_.robot_id_ != robot_id_) ||
+                 (!interrobot_comms_active_ && (var->key_.robot_id_ != robot_id_) && (msg_passing_mode == EXTERNAL))))
+                continue;
+
             // Read message from each connected factor
             var->inbox_[f_key] = fac->outbox_.at(v_key);
         }
@@ -73,4 +83,5 @@ void FactorGraph::variableIteration(MsgPassingMode msg_passing_mode){
         // Update variable belief and create outgoing messages
         var->update_belief();
     };
-;}
+    ;
+}

Commit: b68bb6fde83c338836dd8efa733e0e71fe458efd
------------------------------------
commit b68bb6fde83c338836dd8efa733e0e71fe458efd
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Thu May 9 13:31:00 2024 +0100

    grid

 .DS_Store             | Bin 0 -> 6148 bytes
 assets/.DS_Store      | Bin 0 -> 6148 bytes
 assets/imgs/.DS_Store | Bin 0 -> 6148 bytes
 assets/imgs/grid.png  | Bin 0 -> 105847 bytes
 src/Simulator.cpp     |  42 ++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 42 insertions(+)
diff --git a/.DS_Store b/.DS_Store
new file mode 100644
index 0000000..5974cac
Binary files /dev/null and b/.DS_Store differ
diff --git a/assets/.DS_Store b/assets/.DS_Store
new file mode 100644
index 0000000..1b9a5b6
Binary files /dev/null and b/assets/.DS_Store differ
diff --git a/assets/imgs/.DS_Store b/assets/imgs/.DS_Store
new file mode 100644
index 0000000..0547b9b
Binary files /dev/null and b/assets/imgs/.DS_Store differ
diff --git a/assets/imgs/grid.png b/assets/imgs/grid.png
new file mode 100644
index 0000000..e4cdf8f
Binary files /dev/null and b/assets/imgs/grid.png differ
diff --git a/src/Simulator.cpp b/src/Simulator.cpp
index 569d1b1..e51e033 100644
--- a/src/Simulator.cpp
+++ b/src/Simulator.cpp
@@ -314,6 +314,8 @@ void Simulator::createOrDeleteRobots()
             std::deque<Eigen::VectorXd> waypoints{starting, ending};
             float robot_radius = globals.ROBOT_RADIUS;
             Color robot_color = DARKGREEN;
+            int master_id = -1;
+            bool isMaster = true;
             robots_to_create.push_back(std::make_shared<Robot>(this, next_rid_++, waypoints, robot_radius, robot_color, false, -1));
         }
         // Delete robots if out of bounds
@@ -351,6 +353,8 @@ void Simulator::createOrDeleteRobots()
             std::deque<Eigen::VectorXd> waypoints{starting, turning, ending};
             float robot_radius = globals.ROBOT_RADIUS;
             Color robot_color = ColorFromHSV(turn * 120., 1., 0.75);
+            int master_id = -1;
+            bool isMaster = true;
             robots_to_create.push_back(std::make_shared<Robot>(this, next_rid_++, waypoints, robot_radius, robot_color, false, -1));
         }
 
@@ -363,6 +367,44 @@ void Simulator::createOrDeleteRobots()
             }
         }
     }
+    else if (globals.FORMATION == "grid")
+    {
+        // Robots in a grid style city. There is only one-way traffic, and no turning.
+        new_robots_needed_ = true; // This is needed so that more robots can be created as the simulation progresses.
+        if (clock_ % 20 == 0)
+        { // Arbitrary condition on the simulation time to create new robots
+            // EDIT THIS FOR GRID MAP
+            int n_roads = 2;
+            int road = random_int(0, n_roads - 1);
+            Eigen::Matrix4d rot;
+            rot.setZero();
+            rot.topLeftCorner(2, 2) << cos(PI / 2. * road), -sin(PI / 2. * road), sin(PI / 2. * road), cos(PI / 2. * road);
+            rot.bottomRightCorner(2, 2) << cos(PI / 2. * road), -sin(PI / 2. * road), sin(PI / 2. * road), cos(PI / 2. * road);
+
+            int n_lanes = 2;
+            int lane = random_int(0, n_lanes - 1);
+            double lane_width = 4. * globals.ROBOT_RADIUS;
+            double lane_v_offset = (0.5 * (1 - n_lanes) + lane) * lane_width;
+            starting = rot * Eigen::VectorXd{{-globals.WORLD_SZ / 2., lane_v_offset, globals.MAX_SPEED, 0.}};
+            ending = rot * Eigen::VectorXd{{(double)globals.WORLD_SZ, lane_v_offset, 0., 0.}};
+            std::deque<Eigen::VectorXd> waypoints{starting, ending};
+            // END COMMENT
+
+            float robot_radius = globals.ROBOT_RADIUS;
+            Color robot_color = DARKGREEN;
+            int master_id = -1;
+            bool isMaster = true;
+            robots_to_create.push_back(std::make_shared<Robot>(this, next_rid_++, waypoints, robot_radius, robot_color, false, -1));
+        }
+        // Delete robots if out of bounds
+        for (auto [rid, robot] : robots_)
+        {
+            if (abs(robot->position_(0)) > globals.WORLD_SZ / 2 || abs(robot->position_(1)) > globals.WORLD_SZ / 2)
+            {
+                robots_to_delete.push_back(robot);
+            }
+        }
+    }
     else
     {
         print("Shouldn't reach here, formation not defined!");

Commit: 6d9c3131dde37a5f8bece50295cfc795f80ff226
------------------------------------
commit 6d9c3131dde37a5f8bece50295cfc795f80ff226
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Wed May 1 21:33:37 2024 +0100

    found seg fault with the jacobian function for the MasterSlaveFactor. Removed J_func but now dots have disappeared completely. Master slave connections have been successfully demonstrated but need to be refined

 .vscode/launch.json          | 17 +++++++++++++++
 .vscode/tasks.json           | 29 +++++++++++++++++++++++++
 config/circle_cluttered.json |  2 +-
 inc/Robot.h                  |  2 +-
 inc/gbp/Factor.h             |  2 +-
 src/Robot.cpp                | 51 +++++++++++++++++---------------------------
 src/Simulator.cpp            |  3 ++-
 src/gbp/Factor.cpp           | 37 ++++++++++++++++----------------
 8 files changed, 89 insertions(+), 54 deletions(-)
diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..ed42005
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,17 @@
+{
+    "version": "0.2.0",
+    "configurations": [
+        {
+            "name": "(lldb) Launch",
+            "type": "cppdbg",
+            "request": "launch",
+            "program": "${workspaceFolder}/build/gbpplanner",
+            "args": ["--cfg", "../config/circle_cluttered.json"],
+            "stopAtEntry": false,
+            "cwd": "${workspaceFolder}",
+            "environment": [],
+            "externalConsole": false,
+            "MIMode": "lldb",
+        }
+    ]
+}
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 0000000..c5f9098
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,29 @@
+{
+    "tasks": [
+        {
+            "type": "cppbuild",
+            "label": "C/C++: clang++ build active file",
+            "command": "/opt/homebrew/opt/llvm/bin/clang++",
+            "args": [
+                "-fcolor-diagnostics",
+                "-fansi-escape-codes",
+                "-g",
+                "${file}",
+                "-o",
+                "${fileDirname}/${fileBasenameNoExtension}"
+            ],
+            "options": {
+                "cwd": "${fileDirname}"
+            },
+            "problemMatcher": [
+                "$gcc"
+            ],
+            "group": {
+                "kind": "build",
+                "isDefault": true
+            },
+            "detail": "Task generated by Debugger."
+        }
+    ],
+    "version": "2.0.0"
+}
\ No newline at end of file
diff --git a/config/circle_cluttered.json b/config/circle_cluttered.json
index 36f352b..5cb7962 100644
--- a/config/circle_cluttered.json
+++ b/config/circle_cluttered.json
@@ -27,7 +27,7 @@
   "SIGMA_FACTOR_DYNAMICS": 0.1,
   "SIGMA_FACTOR_INTERROBOT": 0.01,
   "SIGMA_FACTOR_OBSTACLE": 0.01,
-  "SIGMA_FACTOR_MASTERSLAVE": 0.5,
+  "SIGMA_FACTOR_MASTERSLAVE": 0.01,
   "NUM_ITERS": 10
 
 }
\ No newline at end of file
diff --git a/inc/Robot.h b/inc/Robot.h
index 3f9b0d9..0450480 100644
--- a/inc/Robot.h
+++ b/inc/Robot.h
@@ -69,7 +69,7 @@ public:
     void createInterrobotFactors(std::shared_ptr<Robot> other_robot);
     void deleteInterrobotFactors(std::shared_ptr<Robot> other_robot);
 
-    void createMasterSlaveFactors(std::shared_ptr<Robot> master_robot);
+    void createMasterSlaveFactors();
     void updateMasterSlaveFactor();
     /***************************************************************************************************/
     // Drawing function
diff --git a/inc/gbp/Factor.h b/inc/gbp/Factor.h
index b292b15..ec3a1b5 100644
--- a/inc/gbp/Factor.h
+++ b/inc/gbp/Factor.h
@@ -151,7 +151,7 @@ public:
                       std::shared_ptr<Robot> robot, std::shared_ptr<Robot> master_robot);
 
     Eigen::MatrixXd h_func_(const Eigen::VectorXd &X) override;
-    Eigen::MatrixXd J_func_(const Eigen::VectorXd &X) override;
+    // Eigen::MatrixXd J_func_(const Eigen::VectorXd &X) override;
 
 private:
     std::shared_ptr<Robot> robot_;
diff --git a/src/Robot.cpp b/src/Robot.cpp
index 9844261..aaf06f1 100644
--- a/src/Robot.cpp
+++ b/src/Robot.cpp
@@ -303,40 +303,29 @@ Eigen::VectorXd Robot::getPosition() const
 }
 
 /***************************************************************************************************/
-// Create master-slave factors between this robot (slave) and another robot (master)
+// Create master-slave factors between this robot (slave) and its designated master
 /***************************************************************************************************/
-void Robot::createMasterSlaveFactors(std::shared_ptr<Robot> master_robot)
+void Robot::createMasterSlaveFactors()
 {
-    // Create MasterSlave factors for all timesteps excluding current state
-    for (int i = 1; i < num_variables_; i++)
-    {
-        // Get variables
-        std::vector<std::shared_ptr<Variable>> variables{getVar(i), master_robot->getVar(i)};
+    if (!this->isMaster_ && sim_->robots_.count(master_id_))
+    { // Check if it's a slave and master exists
+        std::shared_ptr<Robot> master_robot = sim_->robots_.at(master_id_);
+        // Create MasterSlave factors for all timesteps excluding current state
+        for (int i = 1; i < num_variables_; i++)
+        {
+            // Get variables
+            std::vector<std::shared_ptr<Variable>> variables{getVar(i), master_robot->getVar(i)};
 
-        // Create the master-slave factor
-        Eigen::VectorXd z = Eigen::VectorXd::Zero(variables.front()->n_dofs_);
-        auto factor = std::make_shared<MasterSlaveFactor>(sim_->next_fid_++, this->rid_, variables, globals.SIGMA_FACTOR_MASTERSLAVE, z, shared_from_this(), master_robot);
-        factor->other_rid_ = master_robot->rid_;
-        // Add factor to the variable's list of factors, as well as to the robot's list of factors
-        for (auto var : factor->variables_)
-            var->add_factor(factor);
-        this->factors_[factor->key_] = factor;
-    }
-};
+            // Create the master-slave factor
+            Eigen::VectorXd z = Eigen::VectorXd::Zero(variables.front()->n_dofs_);
 
-/***************************************************************************************************/
-// For new neighbours of a robot, create master-slave factors if they don't exist.
-/***************************************************************************************************/
-void Robot::updateMasterSlaveFactor()
-{
-    // Search through neighbours. If any are not in currently connected rids, create master-slave factors.
-    for (auto rid : neighbours_)
-    {
-        if (std::find(connected_r_ids_.begin(), connected_r_ids_.end(), rid) == connected_r_ids_.end())
-        {
-            createMasterSlaveFactors(sim_->robots_.at(rid));
-            this->connected_r_ids_.push_back(rid);                   // Record the connection
-            sim_->robots_.at(rid)->connected_r_ids_.push_back(rid_); // Reciprocate the connection if needed
+            auto factor = std::make_shared<MasterSlaveFactor>(sim_->next_fid_++, this->rid_, variables, globals.SIGMA_FACTOR_MASTERSLAVE, z, shared_from_this(), master_robot);
+            factor->other_rid_ = master_robot->rid_;
+
+            // Add factor to the variable's list of factors, as well as to the robot's list of factors
+            for (auto var : factor->variables_)
+                var->add_factor(factor);
+            this->factors_[factor->key_] = factor;
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/Simulator.cpp b/src/Simulator.cpp
index ba0167d..569d1b1 100644
--- a/src/Simulator.cpp
+++ b/src/Simulator.cpp
@@ -272,7 +272,7 @@ void Simulator::createOrDeleteRobots()
                                                                        {0.}};
 
             Eigen::VectorXd starting = (i % 2 == 0) ? centre + offset_from_centre_inner : centre + offset_from_centre_outer;
-            Eigen::VectorXd ending = (i % 2 == 0) ? centre - offset_from_centre_inner : centre - offset_from_centre_outer;
+            Eigen::VectorXd ending = (i % 2 == 0) ? centre - offset_from_centre_outer : centre - offset_from_centre_inner;
             // Eigen::VectorXd ending = centre - offset_from_centre_outer;
             std::deque<Eigen::VectorXd>
                 waypoints{starting, ending};
@@ -373,6 +373,7 @@ void Simulator::createOrDeleteRobots()
     {
         robot_positions_[robot->rid_] = std::vector<double>{robot->waypoints_[0](0), robot->waypoints_[0](1)};
         robots_[robot->rid_] = robot;
+        robot->createMasterSlaveFactors();
     };
     for (auto robot : robots_to_delete)
     {
diff --git a/src/gbp/Factor.cpp b/src/gbp/Factor.cpp
index beea0bf..fba9394 100644
--- a/src/gbp/Factor.cpp
+++ b/src/gbp/Factor.cpp
@@ -331,15 +331,13 @@ Eigen::MatrixXd ObstacleFactor::h_func_(const Eigen::VectorXd &X)
 // Master-Slave factor for the master-slave robot system in the scene. This factor is used to keep the slave robot
 // within a certain distance from the master robot. The factor has 0 energy if the slave robot is within the specified distance.
 /********************************************************************************************/
-/********************************************************************************************/
-// Master-Slave factor for the master-slave robot system in the scene. This factor is used to keep the slave robot
-// within a certain distance from the master robot. The factor has 0 energy if the slave robot is within the specified distance.
-/********************************************************************************************/
+
 MasterSlaveFactor::MasterSlaveFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
                                      float sigma, const Eigen::VectorXd &measurement,
                                      std::shared_ptr<Robot> robot, std::shared_ptr<Robot> master_robot)
     : Factor(f_id, r_id, variables, sigma, measurement), robot_(robot), master_(master_robot)
 {
+    printf("MasterSlaveFactor created for robot %d connected to master %d\n", r_id, master_robot->rid_);
     factor_type_ = MASTER_SLAVE_FACTOR;
 }
 
@@ -350,23 +348,24 @@ Eigen::MatrixXd MasterSlaveFactor::h_func_(const Eigen::VectorXd &X)
     {
         Eigen::VectorXd masterPos = master_->getPosition();
         Eigen::VectorXd robotPos = robot_->getPosition();
+        printf("Robot %d at [%f, %f] connected to master %d at [%f, %f]\n", robot_->rid_, robotPos(0), robotPos(1), master_->rid_, masterPos(0), masterPos(1));
         h(0) = (masterPos - robotPos).norm(); // Directly calculate Euclidean distance
     }
     return h;
 }
 
-Eigen::MatrixXd MasterSlaveFactor::J_func_(const Eigen::VectorXd &X)
-{
-    Eigen::MatrixXd J = Eigen::MatrixXd::Zero(1, robot_->getPosition().size());
-    if (master_)
-    {
-        Eigen::VectorXd masterPos = master_->getPosition();
-        Eigen::VectorXd robotPos = robot_->getPosition();
-        double dist = (masterPos - robotPos).norm();
-        if (dist > 0)
-        { // Prevent division by zero
-            J.row(0) = (robotPos - masterPos) / dist;
-        }
-    }
-    return J;
-}
+// Eigen::MatrixXd MasterSlaveFactor::J_func_(const Eigen::VectorXd &X)
+// {
+//     Eigen::MatrixXd J = Eigen::MatrixXd::Zero(1, robot_->getPosition().size());
+//     if (master_)
+//     {
+//         Eigen::VectorXd masterPos = master_->getPosition();
+//         Eigen::VectorXd robotPos = robot_->getPosition();
+//         double dist = (masterPos - robotPos).norm();
+//         if (dist > 0)
+//         { // Prevent division by zero
+//             J.row(0) = (robotPos - masterPos) / dist;
+//         }
+//     }
+//     return J;
+// }
\ No newline at end of file

Commit: 9da955cba7463a48c8833f1a69eb96ba4419694a
------------------------------------
commit 9da955cba7463a48c8833f1a69eb96ba4419694a
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Wed May 1 20:32:51 2024 +0100

    Add SIGMA_FACTOR_MASTERSLAVE parameter to circle_cluttered.json

 config/circle_cluttered.json |  1 +
 inc/Globals.h                | 88 +++++++++++++++++++++++---------------------
 inc/Robot.h                  |  4 +-
 inc/gbp/Factor.h             |  6 +--
 src/Globals.cpp              | 20 +++++-----
 src/Robot.cpp                | 41 ++++++++++++++++++++-
 src/Simulator.cpp            |  4 +-
 src/gbp/Factor.cpp           | 36 ++++++------------
 8 files changed, 118 insertions(+), 82 deletions(-)
diff --git a/config/circle_cluttered.json b/config/circle_cluttered.json
index 014586d..36f352b 100644
--- a/config/circle_cluttered.json
+++ b/config/circle_cluttered.json
@@ -27,6 +27,7 @@
   "SIGMA_FACTOR_DYNAMICS": 0.1,
   "SIGMA_FACTOR_INTERROBOT": 0.01,
   "SIGMA_FACTOR_OBSTACLE": 0.01,
+  "SIGMA_FACTOR_MASTERSLAVE": 0.5,
   "NUM_ITERS": 10
 
 }
\ No newline at end of file
diff --git a/inc/Globals.h b/inc/Globals.h
index 7b9b112..60e54ea 100644
--- a/inc/Globals.h
+++ b/inc/Globals.h
@@ -10,57 +10,63 @@
 #include "json.hpp"
 
 // Simulation modes
-enum MODES_LIST {SimNone, Timestep, Iterate, Help};
+enum MODES_LIST
+{
+    SimNone,
+    Timestep,
+    Iterate,
+    Help
+};
 
 /***********************************************************************************************/
 // Global structure. The values here are mostly set using the provided config.json file.
 /***********************************************************************************************/
-class Globals {
-    public:
-
+class Globals
+{
+public:
     // Basic parameters
-    const char* WINDOW_TITLE = "Distributing Multirobot Motion Planning with Gaussian Belief Propogation";
+    const char *WINDOW_TITLE = "Distributing Multirobot Motion Planning with Gaussian Belief Propogation";
     bool RUN = true;
-    std::string CONFIG_FILE = "../config/config.json";      // Default config file
-    std::string OBSTACLE_FILE;                              // Binary image for obstacles
-    std::string ASSETS_DIR;                                 // Directory for Assets
-    int N_DOFS = 4;                                         // Degrees of freedom (x, y, xdot, ydot)
-    MODES_LIST SIM_MODE = Timestep;                         // Simulation mode to begin with
-    MODES_LIST LAST_SIM_MODE = Timestep;                    // Storage of Simulation mode (if time is paused eg.)
-    
+    std::string CONFIG_FILE = "../config/config.json"; // Default config file
+    std::string OBSTACLE_FILE;                         // Binary image for obstacles
+    std::string ASSETS_DIR;                            // Directory for Assets
+    int N_DOFS = 4;                                    // Degrees of freedom (x, y, xdot, ydot)
+    MODES_LIST SIM_MODE = Timestep;                    // Simulation mode to begin with
+    MODES_LIST LAST_SIM_MODE = Timestep;               // Storage of Simulation mode (if time is paused eg.)
+
     // Display parameters
-    bool DISPLAY;                                           // Show display or not
-    int WORLD_SZ;                                           // [m]
-    int SCREEN_SZ;                                          // [pixels]
-    bool DRAW_INTERROBOT;                                   // Toggle display of inter-robot connections
-    bool DRAW_PATH;                                         // Toggle display of planned paths
-    bool DRAW_WAYPOINTS;                                    // Toggle display of path planning goals
-    
+    bool DISPLAY;         // Show display or not
+    int WORLD_SZ;         // [m]
+    int SCREEN_SZ;        // [pixels]
+    bool DRAW_INTERROBOT; // Toggle display of inter-robot connections
+    bool DRAW_PATH;       // Toggle display of planned paths
+    bool DRAW_WAYPOINTS;  // Toggle display of path planning goals
+
     // Simulation parameters
-    int SEED;                                               // Random Seed 
-    float TIMESTEP;                                         // Simulation timestep [s]
-    int MAX_TIME;                                           // Exit simulation if more timesteps than this
-    int NUM_ROBOTS;                                         // Number of robots (if no new robots are to be added)
-    float T_HORIZON;                                        // Planning horizon [s]
-    float ROBOT_RADIUS;                                     // [m]
-    float COMMUNICATION_RADIUS;                             // [m] Inter-robot factors created if robots are within this range of each other
-    float MAX_SPEED;                                        // [m/s]
-    float COMMS_FAILURE_RATE;                               // Proportion of robots [0,1] that do not communicate
-    int LOOKAHEAD_MULTIPLE = 3;                             // Parameter affecting how planned path is spaced out in time
-    std::string FORMATION;                                    // Robot formation (CIRCLE or JUNCTION)
-    float T0;                                               // Time between current state and next state of planned path
+    int SEED;                   // Random Seed
+    float TIMESTEP;             // Simulation timestep [s]
+    int MAX_TIME;               // Exit simulation if more timesteps than this
+    int NUM_ROBOTS;             // Number of robots (if no new robots are to be added)
+    float T_HORIZON;            // Planning horizon [s]
+    float ROBOT_RADIUS;         // [m]
+    float COMMUNICATION_RADIUS; // [m] Inter-robot factors created if robots are within this range of each other
+    float MAX_SPEED;            // [m/s]
+    float COMMS_FAILURE_RATE;   // Proportion of robots [0,1] that do not communicate
+    int LOOKAHEAD_MULTIPLE = 3; // Parameter affecting how planned path is spaced out in time
+    std::string FORMATION;      // Robot formation (CIRCLE or JUNCTION)
+    float T0;                   // Time between current state and next state of planned path
 
     // GBP parameters
-    float SIGMA_POSE_FIXED = 1e-15;                         // Sigma for Unary pose factor on current and horizon states
-    float SIGMA_FACTOR_DYNAMICS;                            // Sigma for Dynamics factors
-    float SIGMA_FACTOR_INTERROBOT;                          // Sigma for Interrobot factor
-    float SIGMA_FACTOR_OBSTACLE;                            // Sigma for Static obstacle factors
-    int NUM_ITERS;                                          // Number of iterations of GBP per timestep
-    float DAMPING = 0.;                                     // Damping amount (not used in this work)
-    
+    float SIGMA_POSE_FIXED = 1e-15; // Sigma for Unary pose factor on current and horizon states
+    float SIGMA_FACTOR_DYNAMICS;    // Sigma for Dynamics factors
+    float SIGMA_FACTOR_INTERROBOT;  // Sigma for Interrobot factor
+    float SIGMA_FACTOR_OBSTACLE;    // Sigma for Static obstacle factors
+    float SIGMA_FACTOR_MASTERSLAVE; // Sigma for Master-Slave factors
+    int NUM_ITERS;                  // Number of iterations of GBP per timestep
+    float DAMPING = 0.;             // Damping amount (not used in this work)
+
     Globals();
-    int parse_global_args(DArgs::DArgs& dargs);
-    void parse_global_args(std::ifstream& config_file);
+    int parse_global_args(DArgs::DArgs &dargs);
+    void parse_global_args(std::ifstream &config_file);
     void post_parsing();
-
 };
\ No newline at end of file
diff --git a/inc/Robot.h b/inc/Robot.h
index 8f260fa..3f9b0d9 100644
--- a/inc/Robot.h
+++ b/inc/Robot.h
@@ -23,7 +23,7 @@ extern Globals globals;
 //      - Colour
 // This is a derived class from the FactorGraph class
 /***************************************************************************/
-class Robot : public FactorGraph
+class Robot : public FactorGraph, public std::enable_shared_from_this<Robot>
 {
 public:
     // Constructor
@@ -69,6 +69,8 @@ public:
     void createInterrobotFactors(std::shared_ptr<Robot> other_robot);
     void deleteInterrobotFactors(std::shared_ptr<Robot> other_robot);
 
+    void createMasterSlaveFactors(std::shared_ptr<Robot> master_robot);
+    void updateMasterSlaveFactor();
     /***************************************************************************************************/
     // Drawing function
     /***************************************************************************************************/
diff --git a/inc/gbp/Factor.h b/inc/gbp/Factor.h
index e2d1ed6..b292b15 100644
--- a/inc/gbp/Factor.h
+++ b/inc/gbp/Factor.h
@@ -148,14 +148,12 @@ class MasterSlaveFactor : public Factor
 public:
     MasterSlaveFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
                       float sigma, const Eigen::VectorXd &measurement,
-                      std::shared_ptr<Robot> robot, const std::vector<std::shared_ptr<Robot>> &robots);
+                      std::shared_ptr<Robot> robot, std::shared_ptr<Robot> master_robot);
 
     Eigen::MatrixXd h_func_(const Eigen::VectorXd &X) override;
     Eigen::MatrixXd J_func_(const Eigen::VectorXd &X) override;
 
 private:
     std::shared_ptr<Robot> robot_;
-    const std::vector<std::shared_ptr<Robot>> &robots_;
-
-    std::shared_ptr<Robot> findMaster(int master_id);
+    std::shared_ptr<Robot> master_;
 };
\ No newline at end of file
diff --git a/src/Globals.cpp b/src/Globals.cpp
index 0a26f08..30e786d 100644
--- a/src/Globals.cpp
+++ b/src/Globals.cpp
@@ -9,15 +9,17 @@
 /*****************************************************************/
 // Simply reads the appropriate sections from the config.json
 /*****************************************************************/
-void Globals::parse_global_args(std::ifstream& config_file){
-    
+void Globals::parse_global_args(std::ifstream &config_file)
+{
+
     // Basic parameters
     nlohmann::json j;
     config_file >> j;
     ASSETS_DIR = j["ASSETS_DIR"];
 
     // Display parameters
-    DISPLAY = static_cast<bool>((int)j["DISPLAY"]);;
+    DISPLAY = static_cast<bool>((int)j["DISPLAY"]);
+    ;
     WORLD_SZ = j["WORLD_SZ"];
     SCREEN_SZ = j["SCREEN_SZ"];
     DRAW_INTERROBOT = static_cast<bool>((int)j["DRAW_INTERROBOT"]);
@@ -41,8 +43,8 @@ void Globals::parse_global_args(std::ifstream& config_file){
     SIGMA_FACTOR_DYNAMICS = j["SIGMA_FACTOR_DYNAMICS"];
     SIGMA_FACTOR_INTERROBOT = j["SIGMA_FACTOR_INTERROBOT"];
     SIGMA_FACTOR_OBSTACLE = j["SIGMA_FACTOR_OBSTACLE"];
+    SIGMA_FACTOR_MASTERSLAVE = j["SIGMA_FACTOR_MASTERSLAVE"];
     NUM_ITERS = j["NUM_ITERS"];
-
 }
 
 Globals::Globals(){};
@@ -54,7 +56,7 @@ int Globals::parse_global_args(DArgs::DArgs &dargs)
 {
     // Argument parser
     this->CONFIG_FILE = dargs("--cfg", "config_file", this->CONFIG_FILE);
-    
+
     if (!dargs.check())
     {
         dargs.print_help();
@@ -78,10 +80,10 @@ void Globals::post_parsing()
     // Cap max speed, since it should be <= ROBOT_RADIUS/2.f / TIMESTEP:
     // In one timestep a robot should not move more than half of its radius
     // (since we plan for discrete timesteps)
-    if (MAX_SPEED > ROBOT_RADIUS/2.f/TIMESTEP){
-        MAX_SPEED = ROBOT_RADIUS/2.f/TIMESTEP;
+    if (MAX_SPEED > ROBOT_RADIUS / 2.f / TIMESTEP)
+    {
+        MAX_SPEED = ROBOT_RADIUS / 2.f / TIMESTEP;
         print("Capping MAX_SPEED parameter at ", MAX_SPEED);
     }
-    T0 = ROBOT_RADIUS/2.f / MAX_SPEED; // Time between current state and next state of planned path
-
+    T0 = ROBOT_RADIUS / 2.f / MAX_SPEED; // Time between current state and next state of planned path
 }
diff --git a/src/Robot.cpp b/src/Robot.cpp
index 84764c5..9844261 100644
--- a/src/Robot.cpp
+++ b/src/Robot.cpp
@@ -300,4 +300,43 @@ std::vector<int> Robot::getVariableTimesteps(int lookahead_horizon, int lookahea
 Eigen::VectorXd Robot::getPosition() const
 {
     return position_; // Replace with the correct code if position_ is not the correct member
-}
\ No newline at end of file
+}
+
+/***************************************************************************************************/
+// Create master-slave factors between this robot (slave) and another robot (master)
+/***************************************************************************************************/
+void Robot::createMasterSlaveFactors(std::shared_ptr<Robot> master_robot)
+{
+    // Create MasterSlave factors for all timesteps excluding current state
+    for (int i = 1; i < num_variables_; i++)
+    {
+        // Get variables
+        std::vector<std::shared_ptr<Variable>> variables{getVar(i), master_robot->getVar(i)};
+
+        // Create the master-slave factor
+        Eigen::VectorXd z = Eigen::VectorXd::Zero(variables.front()->n_dofs_);
+        auto factor = std::make_shared<MasterSlaveFactor>(sim_->next_fid_++, this->rid_, variables, globals.SIGMA_FACTOR_MASTERSLAVE, z, shared_from_this(), master_robot);
+        factor->other_rid_ = master_robot->rid_;
+        // Add factor to the variable's list of factors, as well as to the robot's list of factors
+        for (auto var : factor->variables_)
+            var->add_factor(factor);
+        this->factors_[factor->key_] = factor;
+    }
+};
+
+/***************************************************************************************************/
+// For new neighbours of a robot, create master-slave factors if they don't exist.
+/***************************************************************************************************/
+void Robot::updateMasterSlaveFactor()
+{
+    // Search through neighbours. If any are not in currently connected rids, create master-slave factors.
+    for (auto rid : neighbours_)
+    {
+        if (std::find(connected_r_ids_.begin(), connected_r_ids_.end(), rid) == connected_r_ids_.end())
+        {
+            createMasterSlaveFactors(sim_->robots_.at(rid));
+            this->connected_r_ids_.push_back(rid);                   // Record the connection
+            sim_->robots_.at(rid)->connected_r_ids_.push_back(rid_); // Reciprocate the connection if needed
+        }
+    }
+}
diff --git a/src/Simulator.cpp b/src/Simulator.cpp
index 5fc1d59..ba0167d 100644
--- a/src/Simulator.cpp
+++ b/src/Simulator.cpp
@@ -272,8 +272,8 @@ void Simulator::createOrDeleteRobots()
                                                                        {0.}};
 
             Eigen::VectorXd starting = (i % 2 == 0) ? centre + offset_from_centre_inner : centre + offset_from_centre_outer;
-            // Eigen::VectorXd ending = (i % 2 == 0) ? centre - offset_from_centre_outer : centre - offset_from_centre_inner;
-            Eigen::VectorXd ending = centre - offset_from_centre_outer;
+            Eigen::VectorXd ending = (i % 2 == 0) ? centre - offset_from_centre_inner : centre - offset_from_centre_outer;
+            // Eigen::VectorXd ending = centre - offset_from_centre_outer;
             std::deque<Eigen::VectorXd>
                 waypoints{starting, ending};
 
diff --git a/src/gbp/Factor.cpp b/src/gbp/Factor.cpp
index 0422f56..beea0bf 100644
--- a/src/gbp/Factor.cpp
+++ b/src/gbp/Factor.cpp
@@ -271,7 +271,7 @@ Eigen::MatrixXd InterrobotFactor::h_func_(const Eigen::VectorXd &X)
     X_diff += 1e-6 * r_id_ * Eigen::VectorXd::Ones(n_dofs_ / 2);
 
     double r = X_diff.norm();
-    if (r <= safety_distance_ && isMaster_ == true)
+    if (r <= safety_distance_)
     {
         this->skip_flag = false;
         h(0) = 1.f * (1 - r / safety_distance_);
@@ -290,7 +290,7 @@ Eigen::MatrixXd InterrobotFactor::J_func_(const Eigen::VectorXd &X)
     Eigen::VectorXd X_diff = X(seqN(0, n_dofs_ / 2)) - X(seqN(n_dofs_, n_dofs_ / 2));
     X_diff += 1e-6 * r_id_ * Eigen::VectorXd::Ones(n_dofs_ / 2); // Add a tiny random offset to avoid div/0 errors
     double r = X_diff.norm();
-    if (r <= safety_distance_ && isMaster_ == true)
+    if (r <= safety_distance_)
     {
         J(0, seqN(0, n_dofs_ / 2)) = -1.f / safety_distance_ / r * X_diff;
         J(0, seqN(n_dofs_, n_dofs_ / 2)) = 1.f / safety_distance_ / r * X_diff;
@@ -327,14 +327,18 @@ Eigen::MatrixXd ObstacleFactor::h_func_(const Eigen::VectorXd &X)
     return h;
 };
 
+/********************************************************************************************/
+// Master-Slave factor for the master-slave robot system in the scene. This factor is used to keep the slave robot
+// within a certain distance from the master robot. The factor has 0 energy if the slave robot is within the specified distance.
+/********************************************************************************************/
 /********************************************************************************************/
 // Master-Slave factor for the master-slave robot system in the scene. This factor is used to keep the slave robot
 // within a certain distance from the master robot. The factor has 0 energy if the slave robot is within the specified distance.
 /********************************************************************************************/
 MasterSlaveFactor::MasterSlaveFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
                                      float sigma, const Eigen::VectorXd &measurement,
-                                     std::shared_ptr<Robot> robot, const std::vector<std::shared_ptr<Robot>> &robots)
-    : Factor(f_id, r_id, variables, sigma, measurement), robot_(robot), robots_(robots)
+                                     std::shared_ptr<Robot> robot, std::shared_ptr<Robot> master_robot)
+    : Factor(f_id, r_id, variables, sigma, measurement), robot_(robot), master_(master_robot)
 {
     factor_type_ = MASTER_SLAVE_FACTOR;
 }
@@ -342,11 +346,9 @@ MasterSlaveFactor::MasterSlaveFactor(int f_id, int r_id, std::vector<std::shared
 Eigen::MatrixXd MasterSlaveFactor::h_func_(const Eigen::VectorXd &X)
 {
     Eigen::MatrixXd h = Eigen::MatrixXd::Zero(1, 1);
-    std::shared_ptr<Robot> master = findMaster(robot_->master_id_);
-
-    if (master)
+    if (master_)
     {
-        Eigen::VectorXd masterPos = master->getPosition();
+        Eigen::VectorXd masterPos = master_->getPosition();
         Eigen::VectorXd robotPos = robot_->getPosition();
         h(0) = (masterPos - robotPos).norm(); // Directly calculate Euclidean distance
     }
@@ -356,11 +358,9 @@ Eigen::MatrixXd MasterSlaveFactor::h_func_(const Eigen::VectorXd &X)
 Eigen::MatrixXd MasterSlaveFactor::J_func_(const Eigen::VectorXd &X)
 {
     Eigen::MatrixXd J = Eigen::MatrixXd::Zero(1, robot_->getPosition().size());
-    std::shared_ptr<Robot> master = findMaster(robot_->master_id_);
-
-    if (master)
+    if (master_)
     {
-        Eigen::VectorXd masterPos = master->getPosition();
+        Eigen::VectorXd masterPos = master_->getPosition();
         Eigen::VectorXd robotPos = robot_->getPosition();
         double dist = (masterPos - robotPos).norm();
         if (dist > 0)
@@ -370,15 +370,3 @@ Eigen::MatrixXd MasterSlaveFactor::J_func_(const Eigen::VectorXd &X)
     }
     return J;
 }
-
-std::shared_ptr<Robot> MasterSlaveFactor::findMaster(int master_id)
-{
-    for (const auto &robot : robots_)
-    {
-        if (robot->rid_ == master_id)
-        {
-            return robot;
-        }
-    }
-    return nullptr; // Return nullptr if no master found (should not happen if IDs are correct)
-}

Commit: 5c26db2d1df50a9f754683fd72fbb32d8df12bcc
------------------------------------
commit 5c26db2d1df50a9f754683fd72fbb32d8df12bcc
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Wed May 1 14:00:26 2024 +0100

    restore previous state

 inc/Simulator.h   |  4 ----
 src/Simulator.cpp | 31 -------------------------------
 2 files changed, 35 deletions(-)
diff --git a/inc/Simulator.h b/inc/Simulator.h
index 793768c..182db95 100644
--- a/inc/Simulator.h
+++ b/inc/Simulator.h
@@ -7,13 +7,11 @@
 #include <map>
 #include <memory>
 #include <algorithm>
-
 #include <Utils.h>
 #include <gbp/GBPCore.h>
 #include <Graphics.h>
 #include <gbp/Variable.h>
 #include <nanoflann.h>
-#include <gbp/Factor.h>
 #include <raylib.h>
 #include <rlights.h>
 #include <nanoflann.h>
@@ -86,8 +84,6 @@ public:
     /*******************************************************************************/
     void calculateRobotNeighbours(std::map<int, std::shared_ptr<Robot>> &robots);
 
-    void initializeMasterSlaveFactors(std::vector<std::shared_ptr<Robot>> &robots_);
-
     /*******************************************************************************/
     // Handles keypresses and mouse input, and updates camera.
     /*******************************************************************************/
diff --git a/src/Simulator.cpp b/src/Simulator.cpp
index 566cf8b..5fc1d59 100644
--- a/src/Simulator.cpp
+++ b/src/Simulator.cpp
@@ -232,36 +232,6 @@ void Simulator::eventHandler()
     graphics->update_camera();
 }
 
-void Simulator::initializeMasterSlaveFactors(std::vector<std::shared_ptr<Robot>> &robots)
-{
-    for (auto &robot : robots)
-    {
-        if (!robot->isMaster_)
-        {
-            auto master_robot = std::find_if(robots.begin(), robots.end(),
-                                             [&](const std::shared_ptr<Robot> &r)
-                                             {
-                                                 return r->rid_ == robot->master_id_;
-                                             });
-
-            if (master_robot != robots.end())
-            {
-                // Assuming robots have synchronized variables and other conditions needed for factor creation
-                // Typically, you would use the horizon variables or similar for these kinds of factors
-                std::shared_ptr<Variable> slave_var = robot->getVar(-1);            // Assuming horizon variable
-                std::shared_ptr<Variable> master_var = (*master_robot)->getVar(-1); // Similarly for master
-
-                auto master_slave_factor = std::make_shared<MasterSlaveFactor>(
-                    this->next_fid_++, robot->rid_, {slave_var, master_var}, globals.SIGMA_FACTOR_OBSTACLE, Eigen::VectorXd::Zero(1), robot, robots // Assuming robots is a std::vector<std::shared_ptr<Robot>> visible in this scope
-                );
-                // Add factor to variables involved in both master and slave robots
-                slave_var->add_factor(master_slave_factor);
-                master_var->add_factor(master_slave_factor);
-            }
-        }
-    }
-}
-
 /*******************************************************************************/
 // Create new robots if needed. Handles deletion of robots out of bounds.
 // New formations must modify the vectors "robots to create" and optionally "robots_to_delete"
@@ -404,7 +374,6 @@ void Simulator::createOrDeleteRobots()
         robot_positions_[robot->rid_] = std::vector<double>{robot->waypoints_[0](0), robot->waypoints_[0](1)};
         robots_[robot->rid_] = robot;
     };
-    initializeMasterSlaveFactors(robots_to_create);
     for (auto robot : robots_to_delete)
     {
         deleteRobot(robot);


Commit: 396b0992f30a34d5947aa4b628aef648d6b8bbb6
------------------------------------
commit 396b0992f30a34d5947aa4b628aef648d6b8bbb6
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Sat Apr 27 14:45:19 2024 +0100

    updated factor.h and factor.cpp with master-slave scaffolding

 inc/gbp/Factor.h   |  33 ++++---
 src/gbp/Factor.cpp | 285 +++++++++++++++++++++++++++++++----------------------
 2 files changed, 183 insertions(+), 135 deletions(-)
diff --git a/inc/gbp/Factor.h b/inc/gbp/Factor.h
index 31faa79..8621f65 100644
--- a/inc/gbp/Factor.h
+++ b/inc/gbp/Factor.h
@@ -25,7 +25,8 @@ enum FactorType
     DEFAULT_FACTOR,
     DYNAMICS_FACTOR,
     INTERROBOT_FACTOR,
-    OBSTACLE_FACTOR
+    OBSTACLE_FACTOR,
+    MASTERSLAVE_FACTOR
 };
 /*****************************************************************************************/
 // Factor used in GBP
@@ -136,21 +137,21 @@ public:
     Eigen::MatrixXd h_func_(const Eigen::VectorXd &X);
 };
 
-class MasterSlaveDistanceFactor : public Factor
-{
-private:
-    int master_robot_id_;               // Master robot id
-    int slave_robot_id_;                // Slave robot id
-    Eigen::VectorXd measurement_;       // Measurement vector
-    Eigen::MatrixXd measurement_model_; // Measurement model
+/********************************************************************************************/
+// Master-Slave factor for the master-slave robot system in the scene. This factor is used to keep the slave robot
+// within a certain distance from the master robot. The factor has 0 energy if the slave robot is within the specified distance.
+/********************************************************************************************/
 
+class MasterSlaveFactor : public Factor
+{
 public:
-    // Constructor
-    MasterSlaveDistanceFactor(Simulator *sim, int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-                              float sigma, const Eigen::VectorXd &measurement, int master_robot_id, int slave_robot_id)
-        : Factor(f_id, r_id, variables, sigma, measurement), master_robot_id_(master_robot_id), slave_robot_id_(slave_robot_id), measurement_(measurement)
-    {
-        // Set up the measurement model in the MasterSlaveDistanceFactor class
-        this->measurement_model_ = Eigen::MatrixXd::Identity(measurement.size(), measurement.size()) / (sigma * sigma);
-    }
+    double distance_threshold_;
+
+    MasterSlaveFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
+                      float sigma, const Eigen::VectorXd &measurement,
+                      double distance_threshold);
+
+    Eigen::MatrixXd h_func_(const Eigen::VectorXd &X);
+    Eigen::MatrixXd J_func_(const Eigen::VectorXd &X);
+    bool skip_factor();
 };
diff --git a/src/gbp/Factor.cpp b/src/gbp/Factor.cpp
index 1876a83..d89983b 100644
--- a/src/gbp/Factor.cpp
+++ b/src/gbp/Factor.cpp
@@ -22,67 +22,78 @@
 //  - n_dofs is the number of degrees of freedom of the variables this factor is connected to. (eg. 4 for [x,y,xdot,ydot])
 /*****************************************************************************************************/
 Factor::Factor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-        float sigma, const Eigen::VectorXd& measurement, 
-        int n_dofs) 
-        : f_id_(f_id), r_id_(r_id), key_(r_id, f_id), variables_(variables), z_(measurement), n_dofs_(n_dofs) {
-
-        // Initialise precision of the measurement function
-        this->meas_model_lambda_ = Eigen::MatrixXd::Identity(z_.rows(), z_.rows()) / pow(sigma,2.);
-        
-        // Initialise empty inbox and outbox
-        int n_dofs_total = 0; int n_dofs_var;
-        for (auto var : variables_) {
-            n_dofs_var = var->n_dofs_;
-            Message zero_msg(n_dofs_var);
-            inbox_[var->key_] = zero_msg;
-            outbox_[var->key_] = zero_msg;
-            n_dofs_total += n_dofs_var;
-        }
+               float sigma, const Eigen::VectorXd &measurement,
+               int n_dofs)
+    : f_id_(f_id), r_id_(r_id), key_(r_id, f_id), variables_(variables), z_(measurement), n_dofs_(n_dofs)
+{
+
+    // Initialise precision of the measurement function
+    this->meas_model_lambda_ = Eigen::MatrixXd::Identity(z_.rows(), z_.rows()) / pow(sigma, 2.);
+
+    // Initialise empty inbox and outbox
+    int n_dofs_total = 0;
+    int n_dofs_var;
+    for (auto var : variables_)
+    {
+        n_dofs_var = var->n_dofs_;
+        Message zero_msg(n_dofs_var);
+        inbox_[var->key_] = zero_msg;
+        outbox_[var->key_] = zero_msg;
+        n_dofs_total += n_dofs_var;
+    }
 
-        // This parameter useful if the factor is connected to another robot
-        other_rid_=r_id_;                           
+    // This parameter useful if the factor is connected to another robot
+    other_rid_ = r_id_;
 
-        // Initialise empty linearisation point
-        X_ = Eigen::VectorXd::Zero(n_dofs_total);
-    };
+    // Initialise empty linearisation point
+    X_ = Eigen::VectorXd::Zero(n_dofs_total);
+};
 
 /*****************************************************************************************************/
 // Destructor
 /*****************************************************************************************************/
-Factor::~Factor(){
+Factor::~Factor()
+{
 }
 
 /*****************************************************************************************************/
 // Drawing function for the factor. Draws a 3d Cylinder (line-ish) between its connected variables
 /*****************************************************************************************************/
-void Factor::draw(){
-    if ((factor_type_==DYNAMICS_FACTOR && globals.DRAW_PATH)){
+void Factor::draw()
+{
+    if ((factor_type_ == DYNAMICS_FACTOR && globals.DRAW_PATH))
+    {
         auto v_0 = variables_[0];
         auto v_1 = variables_[1];
-        if (!v_0->valid_ || !v_1->valid_) {return;};
+        if (!v_0->valid_ || !v_1->valid_)
+        {
+            return;
+        };
         DrawCylinderEx(Vector3{(float)v_0->mu_(0), globals.ROBOT_RADIUS, (float)v_0->mu_(1)},
-                        Vector3{(float)v_1->mu_(0), globals.ROBOT_RADIUS, (float)v_1->mu_(1)}, 
-                        0.1, 0.1, 4, BLACK);        
-    }    
+                       Vector3{(float)v_1->mu_(0), globals.ROBOT_RADIUS, (float)v_1->mu_(1)},
+                       0.1, 0.1, 4, BLACK);
+    }
 }
 
 /*****************************************************************************************************/
 // Default measurement function h_func_() is the identity function: it returns the variable.
 /*****************************************************************************************************/
-Eigen::MatrixXd h_func_(const Eigen::VectorXd& X){return X;};
+Eigen::MatrixXd h_func_(const Eigen::VectorXd &X) { return X; };
 /*****************************************************************************************************/
 // Default measurement function Jacobian J_func_() is the first order taylor series jacobian by default.
 // When defining new factors, custom h_func_() and J_func_() must be defined, otherwise defaults are used.
 /*****************************************************************************************************/
-Eigen::MatrixXd Factor::J_func_(const Eigen::VectorXd& X){return this->jacobianFirstOrder(X);};
-
-Eigen::MatrixXd Factor::jacobianFirstOrder(const Eigen::VectorXd& X0){
-    Eigen::MatrixXd h0 = h_func_(X0);    // Value at lin point
-    Eigen::MatrixXd jac_out = Eigen::MatrixXd::Zero(h0.size(),X0.size());
-    for (int i=0; i<X0.size(); i++){
-        Eigen::VectorXd X_copy = X0;                                    // Copy of lin point
-        X_copy(i) += delta_jac;                                         // Perturb by delta
-        jac_out(Eigen::all, i) = (h_func_(X_copy) - h0) / delta_jac;    // Derivative (first order)
+Eigen::MatrixXd Factor::J_func_(const Eigen::VectorXd &X) { return this->jacobianFirstOrder(X); };
+
+Eigen::MatrixXd Factor::jacobianFirstOrder(const Eigen::VectorXd &X0)
+{
+    Eigen::MatrixXd h0 = h_func_(X0); // Value at lin point
+    Eigen::MatrixXd jac_out = Eigen::MatrixXd::Zero(h0.size(), X0.size());
+    for (int i = 0; i < X0.size(); i++)
+    {
+        Eigen::VectorXd X_copy = X0;                                 // Copy of lin point
+        X_copy(i) += delta_jac;                                      // Perturb by delta
+        jac_out(Eigen::all, i) = (h_func_(X_copy) - h0) / delta_jac; // Derivative (first order)
     }
     return jac_out;
 };
@@ -93,14 +104,17 @@ Eigen::MatrixXd Factor::jacobianFirstOrder(const Eigen::VectorXd& X0){
 // The Factor potential is calculated using h_func_ and J_func_
 // The factor precision and information is created, and then marginalised to create outgoing messages to its connected variables.
 /*****************************************************************************************************/
-bool Factor::update_factor(){
+bool Factor::update_factor()
+{
 
     // Messages from connected variables are aggregated.
     // The beliefs are used to create the linearisation point X_.
-    int idx = 0; int n_dofs;
-    for (int v=0; v<variables_.size(); v++){
+    int idx = 0;
+    int n_dofs;
+    for (int v = 0; v < variables_.size(); v++)
+    {
         n_dofs = variables_[v]->n_dofs_;
-        auto& [_, __, mu_belief] = this->inbox_[variables_[v]->key_];
+        auto &[_, __, mu_belief] = this->inbox_[variables_[v]->key_];
         X_(seqN(idx, n_dofs)) = mu_belief;
         idx += n_dofs;
     }
@@ -108,42 +122,47 @@ bool Factor::update_factor(){
     // *Depending on the problem*, we may need to skip computation of this factor.
     // eg. to avoid extra computation, factor may not be required if two connected variables are too far apart.
     // in which case send out a Zero Message.
-    if (this->skip_factor()){
-        for (auto var : variables_){
+    if (this->skip_factor())
+    {
+        for (auto var : variables_)
+        {
             this->outbox_[var->key_] = Message(var->n_dofs_);
-        }           
+        }
         return false;
     }
-    
+
     // The Factor potential and linearised Factor Precision and Information is calculated using h_func_ and J_func_
     // residual() is by default (z - h_func_(X))
     // Skip calculation of Jacobian if the factor is linear and Jacobian has already been computed once
     h_ = h_func_(X_);
-    J_ = (this->linear_ && this->initialised_)? J_ : this->J_func_(X_);
+    J_ = (this->linear_ && this->initialised_) ? J_ : this->J_func_(X_);
     Eigen::MatrixXd factor_lam_potential = J_.transpose() * meas_model_lambda_ * J_;
     Eigen::VectorXd factor_eta_potential = (J_.transpose() * meas_model_lambda_) * (J_ * X_ + residual());
     this->initialised_ = true;
 
     //  Update factor precision and information with incoming messages from connected variables.
     int marginalisation_idx = 0;
-    for (int v_out_idx=0; v_out_idx<variables_.size(); v_out_idx++){
+    for (int v_out_idx = 0; v_out_idx < variables_.size(); v_out_idx++)
+    {
         auto var_out = variables_[v_out_idx];
         // Initialise with factor values
-        Eigen::VectorXd factor_eta = factor_eta_potential;     
+        Eigen::VectorXd factor_eta = factor_eta_potential;
         Eigen::MatrixXd factor_lam = factor_lam_potential;
-        
+
         // Combine the factor with the belief from other variables apart from the receiving variable
         int idx_v = 0;
-        for (int v_idx=0; v_idx<variables_.size(); v_idx++){
+        for (int v_idx = 0; v_idx < variables_.size(); v_idx++)
+        {
             int n_dofs = variables_[v_idx]->n_dofs_;
-            if (variables_[v_idx]->key_ != var_out->key_) {
+            if (variables_[v_idx]->key_ != var_out->key_)
+            {
                 auto [eta_belief, lam_belief, _] = inbox_[variables_[v_idx]->key_];
                 factor_eta(seqN(idx_v, n_dofs)) += eta_belief;
                 factor_lam(seqN(idx_v, n_dofs), seqN(idx_v, n_dofs)) += lam_belief;
             }
             idx_v += n_dofs;
         }
-        
+
         // Marginalise the Factor Precision and Information to send to the relevant variable
         outbox_[var_out->key_] = marginalise_factor_dist(factor_eta, factor_lam, v_out_idx, marginalisation_idx);
         marginalisation_idx += var_out->n_dofs_;
@@ -155,31 +174,34 @@ bool Factor::update_factor(){
 /*****************************************************************************************************/
 // Marginalise the factor Precision and Information and create the outgoing message to the variable
 /*****************************************************************************************************/
-Message Factor::marginalise_factor_dist(const Eigen::VectorXd &eta, const Eigen::MatrixXd &Lam, int var_idx, int marg_idx){
+Message Factor::marginalise_factor_dist(const Eigen::VectorXd &eta, const Eigen::MatrixXd &Lam, int var_idx, int marg_idx)
+{
     // Marginalisation only needed if factor is connected to >1 variables
     int n_dofs = variables_[var_idx]->n_dofs_;
-    if (eta.size() == n_dofs) return Message {eta, Lam};
+    if (eta.size() == n_dofs)
+        return Message{eta, Lam};
 
-    Eigen::VectorXd eta_a(n_dofs), eta_b(eta.size()-n_dofs);
+    Eigen::VectorXd eta_a(n_dofs), eta_b(eta.size() - n_dofs);
     eta_a = eta(seqN(marg_idx, n_dofs));
     eta_b << eta(seq(0, marg_idx - 1)), eta(seq(marg_idx + n_dofs, last));
 
-    Eigen::MatrixXd lam_aa(n_dofs, n_dofs), lam_ab(n_dofs, Lam.cols()-n_dofs);
-    Eigen::MatrixXd lam_ba(Lam.rows()-n_dofs, n_dofs), lam_bb(Lam.rows()-n_dofs, Lam.cols()-n_dofs);
+    Eigen::MatrixXd lam_aa(n_dofs, n_dofs), lam_ab(n_dofs, Lam.cols() - n_dofs);
+    Eigen::MatrixXd lam_ba(Lam.rows() - n_dofs, n_dofs), lam_bb(Lam.rows() - n_dofs, Lam.cols() - n_dofs);
     lam_aa << Lam(seqN(marg_idx, n_dofs), seqN(marg_idx, n_dofs));
     lam_ab << Lam(seqN(marg_idx, n_dofs), seq(0, marg_idx - 1)), Lam(seqN(marg_idx, n_dofs), seq(marg_idx + n_dofs, last));
     lam_ba << Lam(seq(0, marg_idx - 1), seq(marg_idx, marg_idx + n_dofs - 1)), Lam(seq(marg_idx + n_dofs, last), seqN(marg_idx, n_dofs));
     lam_bb << Lam(seq(0, marg_idx - 1), seq(0, marg_idx - 1)), Lam(seq(0, marg_idx - 1), seq(marg_idx + n_dofs, last)),
-            Lam(seq(marg_idx + n_dofs, last), seq(0, marg_idx - 1)), Lam(seq(marg_idx + n_dofs, last), seq(marg_idx + n_dofs, last));
+        Lam(seq(marg_idx + n_dofs, last), seq(0, marg_idx - 1)), Lam(seq(marg_idx + n_dofs, last), seq(marg_idx + n_dofs, last));
 
     Eigen::MatrixXd lam_bb_inv = lam_bb.inverse();
     Message marginalised_msg(n_dofs);
     marginalised_msg.eta = eta_a - lam_ab * lam_bb_inv * eta_b;
     marginalised_msg.lambda = lam_aa - lam_ab * lam_bb_inv * lam_ba;
-    if (!marginalised_msg.lambda.allFinite()) marginalised_msg.setZero();
+    if (!marginalised_msg.lambda.allFinite())
+        marginalised_msg.setZero();
 
     return marginalised_msg;
-};    
+};
 
 /********************************************************************************************/
 /********************************************************************************************/
@@ -192,104 +214,129 @@ Message Factor::marginalise_factor_dist(const Eigen::VectorXd &eta, const Eigen:
 /* Dynamics factor: constant-velocity model */
 /*****************************************************************************************************/
 DynamicsFactor::DynamicsFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-    float sigma, const Eigen::VectorXd& measurement, 
-    float dt)
-    : Factor{f_id, r_id, variables, sigma, measurement}{ 
-        factor_type_ = DYNAMICS_FACTOR;
-        Eigen::MatrixXd I = Eigen::MatrixXd::Identity(n_dofs_/2,n_dofs_/2);
-        Eigen::MatrixXd O = Eigen::MatrixXd::Zero(n_dofs_/2,n_dofs_/2);
-        Eigen::MatrixXd Qc_inv = pow(sigma, -2.) * I;
-
-        Eigen::MatrixXd Qi_inv(n_dofs_, n_dofs_);
-        Qi_inv << 12.*pow(dt, -3.) * Qc_inv,   -6.*pow(dt, -2.) * Qc_inv,
-                  -6.*pow(dt, -2.) * Qc_inv,   4./dt * Qc_inv;   
-
-        this->meas_model_lambda_ = Qi_inv;        
-
-        // Store Jacobian as it is linear
-        this->linear_ = true;
-        J_ = Eigen::MatrixXd::Zero(n_dofs_, n_dofs_*2);
-        J_ << I, dt*I, -1*I,    O,
-             O,    I,    O, -1*I; 
-
-    };
+                               float sigma, const Eigen::VectorXd &measurement,
+                               float dt)
+    : Factor{f_id, r_id, variables, sigma, measurement}
+{
+    factor_type_ = DYNAMICS_FACTOR;
+    Eigen::MatrixXd I = Eigen::MatrixXd::Identity(n_dofs_ / 2, n_dofs_ / 2);
+    Eigen::MatrixXd O = Eigen::MatrixXd::Zero(n_dofs_ / 2, n_dofs_ / 2);
+    Eigen::MatrixXd Qc_inv = pow(sigma, -2.) * I;
+
+    Eigen::MatrixXd Qi_inv(n_dofs_, n_dofs_);
+    Qi_inv << 12. * pow(dt, -3.) * Qc_inv, -6. * pow(dt, -2.) * Qc_inv,
+        -6. * pow(dt, -2.) * Qc_inv, 4. / dt * Qc_inv;
+
+    this->meas_model_lambda_ = Qi_inv;
+
+    // Store Jacobian as it is linear
+    this->linear_ = true;
+    J_ = Eigen::MatrixXd::Zero(n_dofs_, n_dofs_ * 2);
+    J_ << I, dt * I, -1 * I, O,
+        O, I, O, -1 * I;
+};
 
-Eigen::MatrixXd DynamicsFactor::h_func_(const Eigen::VectorXd& X){
+Eigen::MatrixXd DynamicsFactor::h_func_(const Eigen::VectorXd &X)
+{
     return J_ * X;
-}    
-Eigen::MatrixXd DynamicsFactor::J_func_(const Eigen::VectorXd& X){
+}
+Eigen::MatrixXd DynamicsFactor::J_func_(const Eigen::VectorXd &X)
+{
     return J_;
 }
 
 /********************************************************************************************/
 /* Interrobot factor: for avoidance of other robots */
-// This factor results in a high energy or cost if two robots are planning to be in the same 
+// This factor results in a high energy or cost if two robots are planning to be in the same
 // position at the same timestep (collision). This factor is created between variables of two robots.
 // The factor has 0 energy if the variables are further away than the safety distance. skip_ = true in this case.
 /********************************************************************************************/
 
 InterrobotFactor::InterrobotFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-    float sigma, const Eigen::VectorXd& measurement, 
-    float robot_radius)
-    : Factor{f_id, r_id, variables, sigma, measurement} {  
-        factor_type_ = INTERROBOT_FACTOR;
-        float eps = 0.2 * robot_radius;
-        this->safety_distance_ = 2*robot_radius + eps;
-        this->delta_jac = 1e-2;
+                                   float sigma, const Eigen::VectorXd &measurement,
+                                   float robot_radius)
+    : Factor{f_id, r_id, variables, sigma, measurement}
+{
+    factor_type_ = INTERROBOT_FACTOR;
+    float eps = 0.2 * robot_radius;
+    this->safety_distance_ = 2 * robot_radius + eps;
+    this->delta_jac = 1e-2;
 };
 
-Eigen::MatrixXd InterrobotFactor::h_func_(const Eigen::VectorXd& X){
-    Eigen::MatrixXd h = Eigen::MatrixXd::Zero(z_.rows(),z_.cols());
-    Eigen::VectorXd X_diff = X(seqN(0,n_dofs_/2)) - X(seqN(n_dofs_, n_dofs_/2));
-    X_diff += 1e-6*r_id_*Eigen::VectorXd::Ones(n_dofs_/2);
+Eigen::MatrixXd InterrobotFactor::h_func_(const Eigen::VectorXd &X)
+{
+    Eigen::MatrixXd h = Eigen::MatrixXd::Zero(z_.rows(), z_.cols());
+    Eigen::VectorXd X_diff = X(seqN(0, n_dofs_ / 2)) - X(seqN(n_dofs_, n_dofs_ / 2));
+    X_diff += 1e-6 * r_id_ * Eigen::VectorXd::Ones(n_dofs_ / 2);
 
     double r = X_diff.norm();
-    if (r <= safety_distance_){
+    if (r <= safety_distance_)
+    {
         this->skip_flag = false;
-        h(0) = 1.f*(1 - r/safety_distance_);
+        h(0) = 1.f * (1 - r / safety_distance_);
     }
-    else {
+    else
+    {
         this->skip_flag = true;
     }
 
     return h;
 };
 
-Eigen::MatrixXd InterrobotFactor::J_func_(const Eigen::VectorXd& X){
-    Eigen::MatrixXd J = Eigen::MatrixXd::Zero(z_.rows(), n_dofs_*2);
-    Eigen::VectorXd X_diff = X(seqN(0,n_dofs_/2)) - X(seqN(n_dofs_, n_dofs_/2));
-    X_diff += 1e-6*r_id_*Eigen::VectorXd::Ones(n_dofs_/2);// Add a tiny random offset to avoid div/0 errors
+Eigen::MatrixXd InterrobotFactor::J_func_(const Eigen::VectorXd &X)
+{
+    Eigen::MatrixXd J = Eigen::MatrixXd::Zero(z_.rows(), n_dofs_ * 2);
+    Eigen::VectorXd X_diff = X(seqN(0, n_dofs_ / 2)) - X(seqN(n_dofs_, n_dofs_ / 2));
+    X_diff += 1e-6 * r_id_ * Eigen::VectorXd::Ones(n_dofs_ / 2); // Add a tiny random offset to avoid div/0 errors
     double r = X_diff.norm();
-    if (r <= safety_distance_){
-        J(0,seqN(0, n_dofs_/2)) = -1.f/safety_distance_/r * X_diff;
-        J(0,seqN(n_dofs_, n_dofs_/2)) = 1.f/safety_distance_/r * X_diff;
+    if (r <= safety_distance_)
+    {
+        J(0, seqN(0, n_dofs_ / 2)) = -1.f / safety_distance_ / r * X_diff;
+        J(0, seqN(n_dofs_, n_dofs_ / 2)) = 1.f / safety_distance_ / r * X_diff;
     }
     return J;
 };
 
-bool InterrobotFactor::skip_factor(){
-    this->skip_flag = ( (X_(seqN(0,n_dofs_/2)) - X_(seqN(n_dofs_, n_dofs_/2))).squaredNorm() >= safety_distance_*safety_distance_ );
+bool InterrobotFactor::skip_factor()
+{
+    this->skip_flag = ((X_(seqN(0, n_dofs_ / 2)) - X_(seqN(n_dofs_, n_dofs_ / 2))).squaredNorm() >= safety_distance_ * safety_distance_);
     return this->skip_flag;
 }
 
-
 /********************************************************************************************/
 // Obstacle factor for static obstacles in the scene. This factor takes a pointer to the obstacle image from the Simulator.
 // Note. in the obstacle image, white areas represent obstacles (as they have a value of 1).
 // The input image to the simulator is opposite, which is why it needs to be inverted.
 // The delta used in the first order jacobian calculation is chosen such that it represents one pixel in the image.
 /********************************************************************************************/
-ObstacleFactor::ObstacleFactor(Simulator* sim, int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-    float sigma, const Eigen::VectorXd& measurement, Image* p_obstacleImage)
-    : Factor{f_id, r_id, variables, sigma, measurement}, p_obstacleImage_(p_obstacleImage){
-        factor_type_ = OBSTACLE_FACTOR;
-        this->delta_jac = 1.*(float)globals.WORLD_SZ / (float)p_obstacleImage->width;
+ObstacleFactor::ObstacleFactor(Simulator *sim, int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
+                               float sigma, const Eigen::VectorXd &measurement, Image *p_obstacleImage)
+    : Factor{f_id, r_id, variables, sigma, measurement}, p_obstacleImage_(p_obstacleImage)
+{
+    factor_type_ = OBSTACLE_FACTOR;
+    this->delta_jac = 1. * (float)globals.WORLD_SZ / (float)p_obstacleImage->width;
 };
-Eigen::MatrixXd ObstacleFactor::h_func_(const Eigen::VectorXd& X){
-    Eigen::MatrixXd h = Eigen::MatrixXd::Zero(1,1);
+Eigen::MatrixXd ObstacleFactor::h_func_(const Eigen::VectorXd &X)
+{
+    Eigen::MatrixXd h = Eigen::MatrixXd::Zero(1, 1);
     // White areas are obstacles, so h(0) should return a 1 for these regions.
     float scale = p_obstacleImage_->width / (float)globals.WORLD_SZ;
-    Vector3 c_hsv = ColorToHSV(GetImageColor(*p_obstacleImage_, (int)((X(0) + globals.WORLD_SZ/2) * scale), (int)((X(1) + globals.WORLD_SZ/2) * scale)));
+    Vector3 c_hsv = ColorToHSV(GetImageColor(*p_obstacleImage_, (int)((X(0) + globals.WORLD_SZ / 2) * scale), (int)((X(1) + globals.WORLD_SZ / 2) * scale)));
     h(0) = c_hsv.z;
     return h;
-};
\ No newline at end of file
+};
+
+/********************************************************************************************/
+// Master-Slave factor for the master-slave robot system in the scene. This factor is used to keep the slave robot
+// within a certain distance from the master robot. The factor has 0 energy if the slave robot is within the specified distance.
+/********************************************************************************************/
+
+MasterSlaveFactor::MasterSlaveFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
+                                     float sigma, const Eigen::VectorXd &measurement,
+                                     double distance_threshold)
+    : Factor{f_id, r_id, variables, sigma, measurement}
+{
+    factor_type_ = MASTERSLAVE_FACTOR;
+    this->distance_threshold_ = distance_threshold;
+    this->delta_jac = 1e-2;
+};

Commit: 04ae254eca201c065f37f73359527071c256d013
------------------------------------
commit 04ae254eca201c065f37f73359527071c256d013
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Sat Apr 27 14:30:22 2024 +0100

    Refactor robot creation logic in Simulator.cpp to include master-slave relationship

 inc/gbp/Factor.h | 130 ++++++++++++++++++++++++++++++++-----------------------
 1 file changed, 77 insertions(+), 53 deletions(-)
diff --git a/inc/gbp/Factor.h b/inc/gbp/Factor.h
index 9469251..31faa79 100644
--- a/inc/gbp/Factor.h
+++ b/inc/gbp/Factor.h
@@ -13,59 +13,65 @@
 
 extern Globals globals;
 
-using Eigen::seqN;
-using Eigen::seq;
 using Eigen::last;
+using Eigen::seq;
+using Eigen::seqN;
 
-class Variable;     // Forward declaration
+class Variable; // Forward declaration
 
 // Types of factors defined. Default is DEFAULT_FACTOR
-enum FactorType {DEFAULT_FACTOR, DYNAMICS_FACTOR, INTERROBOT_FACTOR, OBSTACLE_FACTOR};
+enum FactorType
+{
+    DEFAULT_FACTOR,
+    DYNAMICS_FACTOR,
+    INTERROBOT_FACTOR,
+    OBSTACLE_FACTOR
+};
 /*****************************************************************************************/
 // Factor used in GBP
 /*****************************************************************************************/
-class Factor {
-    public:
-    Simulator* sim_;                            // Pointer to simulator
-    int f_id_;                                  // Factor id
-    int r_id_;                                  // Robot id this factor belongs to
-    Key key_;                                   // Factor key = {r_id_, f_id_}
-    int other_rid_;                             // id of other connected robot (if this is an inter-robot factor)
-    int n_dofs_;                                // n_dofs of the variables connected to this factor
-    Eigen::VectorXd z_;                         // Measurement
-    Eigen::MatrixXd h_, J_;                     // Stored values of measurement function h_func_() and Jacobian J_func_()
-    Eigen::VectorXd X_;                         // Stored linearisation point
-    Eigen::MatrixXd meas_model_lambda_;         // Precision of measurement model
-    Mailbox inbox_, outbox_, last_outbox_;      
-    FactorType factor_type_ = DEFAULT_FACTOR; 
-    float delta_jac=1e-8;                       // Delta used for first order jacobian calculation
-    bool initialised_ = false;                  // Becomes true when Jacobian calculated for the first time
-    bool linear_ = false;                       // True is factor is linear (avoids recomputation of Jacobian)
-    bool skip_flag = false;                          // Flag to skip factor update if required
-    virtual bool skip_factor(){                 // Default function to set skip flag
+class Factor
+{
+public:
+    Simulator *sim_;                    // Pointer to simulator
+    int f_id_;                          // Factor id
+    int r_id_;                          // Robot id this factor belongs to
+    Key key_;                           // Factor key = {r_id_, f_id_}
+    int other_rid_;                     // id of other connected robot (if this is an inter-robot factor)
+    int n_dofs_;                        // n_dofs of the variables connected to this factor
+    Eigen::VectorXd z_;                 // Measurement
+    Eigen::MatrixXd h_, J_;             // Stored values of measurement function h_func_() and Jacobian J_func_()
+    Eigen::VectorXd X_;                 // Stored linearisation point
+    Eigen::MatrixXd meas_model_lambda_; // Precision of measurement model
+    Mailbox inbox_, outbox_, last_outbox_;
+    FactorType factor_type_ = DEFAULT_FACTOR;
+    float delta_jac = 1e-8;    // Delta used for first order jacobian calculation
+    bool initialised_ = false; // Becomes true when Jacobian calculated for the first time
+    bool linear_ = false;      // True is factor is linear (avoids recomputation of Jacobian)
+    bool skip_flag = false;    // Flag to skip factor update if required
+    virtual bool skip_factor()
+    { // Default function to set skip flag
         skip_flag = false;
         return skip_flag;
     };
-    std::vector<std::shared_ptr<Variable>> variables_{};    // Vector of pointers to the connected variables. Order of variables matters
-
-    
+    std::vector<std::shared_ptr<Variable>> variables_{}; // Vector of pointers to the connected variables. Order of variables matters
 
     // Function declarations
     Factor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-            float sigma, const Eigen::VectorXd& measurement, 
-            int n_dofs=4);
+           float sigma, const Eigen::VectorXd &measurement,
+           int n_dofs = 4);
 
     ~Factor();
 
     void draw();
 
-    virtual Eigen::MatrixXd h_func_(const Eigen::VectorXd& X) = 0;
+    virtual Eigen::MatrixXd h_func_(const Eigen::VectorXd &X) = 0;
 
-    virtual Eigen::MatrixXd J_func_(const Eigen::VectorXd& X);
+    virtual Eigen::MatrixXd J_func_(const Eigen::VectorXd &X);
 
-    Eigen::MatrixXd jacobianFirstOrder(const Eigen::VectorXd& X0);
+    Eigen::MatrixXd jacobianFirstOrder(const Eigen::VectorXd &X0);
 
-    virtual Eigen::VectorXd residual(){return z_ - h_;};
+    virtual Eigen::VectorXd residual() { return z_ - h_; };
 
     bool update_factor();
 
@@ -82,36 +88,35 @@ class Factor {
 /********************************************************************************************/
 /* Dynamics factor: constant-velocity model */
 /*****************************************************************************************************/
-class DynamicsFactor: public Factor {
-    public:
-
+class DynamicsFactor : public Factor
+{
+public:
     DynamicsFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-        float sigma, const Eigen::VectorXd& measurement, float dt);
+                   float sigma, const Eigen::VectorXd &measurement, float dt);
 
     // Constant velocity model
-    Eigen::MatrixXd h_func_(const Eigen::VectorXd& X);
-    Eigen::MatrixXd J_func_(const Eigen::VectorXd& X);
-
+    Eigen::MatrixXd h_func_(const Eigen::VectorXd &X);
+    Eigen::MatrixXd J_func_(const Eigen::VectorXd &X);
 };
 
 /********************************************************************************************/
 /* Interrobot factor: for avoidance of other robots */
-// This factor results in a high energy or cost if two robots are planning to be in the same 
+// This factor results in a high energy or cost if two robots are planning to be in the same
 // position at the same timestep (collision). This factor is created between variables of two robots.
 // The factor has 0 energy if the variables are further away than the safety distance. skip_ = true in this case.
 /********************************************************************************************/
-class InterrobotFactor: public Factor {
-    public:
+class InterrobotFactor : public Factor
+{
+public:
     double safety_distance_;
 
     InterrobotFactor(int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-        float sigma, const Eigen::VectorXd& measurement, 
-        float robot_radius);
+                     float sigma, const Eigen::VectorXd &measurement,
+                     float robot_radius);
 
-    Eigen::MatrixXd h_func_(const Eigen::VectorXd& X);
-    Eigen::MatrixXd J_func_(const Eigen::VectorXd& X);
+    Eigen::MatrixXd h_func_(const Eigen::VectorXd &X);
+    Eigen::MatrixXd J_func_(const Eigen::VectorXd &X);
     bool skip_factor();
-
 };
 
 /********************************************************************************************/
@@ -120,13 +125,32 @@ class InterrobotFactor: public Factor {
 // The input image to the simulator is opposite, which is why it needs to be inverted.
 // The delta used in the first order jacobian calculation is chosen such that it represents one pixel in the image.
 /********************************************************************************************/
-class ObstacleFactor: public Factor {
-    public:
-    Image* p_obstacleImage_;
+class ObstacleFactor : public Factor
+{
+public:
+    Image *p_obstacleImage_;
 
-    ObstacleFactor(Simulator* sim, int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
-        float sigma, const Eigen::VectorXd& measurement, Image* p_obstacleImage);
+    ObstacleFactor(Simulator *sim, int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
+                   float sigma, const Eigen::VectorXd &measurement, Image *p_obstacleImage);
 
-    Eigen::MatrixXd h_func_(const Eigen::VectorXd& X);
+    Eigen::MatrixXd h_func_(const Eigen::VectorXd &X);
+};
 
+class MasterSlaveDistanceFactor : public Factor
+{
+private:
+    int master_robot_id_;               // Master robot id
+    int slave_robot_id_;                // Slave robot id
+    Eigen::VectorXd measurement_;       // Measurement vector
+    Eigen::MatrixXd measurement_model_; // Measurement model
+
+public:
+    // Constructor
+    MasterSlaveDistanceFactor(Simulator *sim, int f_id, int r_id, std::vector<std::shared_ptr<Variable>> variables,
+                              float sigma, const Eigen::VectorXd &measurement, int master_robot_id, int slave_robot_id)
+        : Factor(f_id, r_id, variables, sigma, measurement), master_robot_id_(master_robot_id), slave_robot_id_(slave_robot_id), measurement_(measurement)
+    {
+        // Set up the measurement model in the MasterSlaveDistanceFactor class
+        this->measurement_model_ = Eigen::MatrixXd::Identity(measurement.size(), measurement.size()) / (sigma * sigma);
+    }
 };

Commit: be7fc65caac6f74a231b4c63cd9691378b83bd4f
------------------------------------
commit be7fc65caac6f74a231b4c63cd9691378b83bd4f
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Fri Apr 26 02:29:40 2024 +0100

    Fix member variable names in Simulator.cpp

 src/Simulator.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
diff --git a/src/Simulator.cpp b/src/Simulator.cpp
index 36669c4..b2101c6 100644
--- a/src/Simulator.cpp
+++ b/src/Simulator.cpp
@@ -69,8 +69,8 @@ void Simulator::draw()
     {
         robot->draw();
         if (!robot->isMaster_)
-        {                                                        // Correct member variable name
-            auto master_robot = robots_.find(robot->master_id_); // Correct member variable name
+        {
+            auto master_robot = robots_.find(robot->master_id_);
             if (master_robot != robots_.end())
             {
                 // Cast positions to float explicitly

Commit: 3b22c30b857c7f92944a8b05ced5011df06ba9b1
------------------------------------
commit 3b22c30b857c7f92944a8b05ced5011df06ba9b1
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Fri Apr 26 02:06:12 2024 +0100

    draw lines between master and slave

 src/Simulator.cpp | 25 ++++++++++++++++++++++---
 1 file changed, 22 insertions(+), 3 deletions(-)
diff --git a/src/Simulator.cpp b/src/Simulator.cpp
index f9318c6..36669c4 100644
--- a/src/Simulator.cpp
+++ b/src/Simulator.cpp
@@ -64,13 +64,32 @@ void Simulator::draw()
     BeginMode3D(graphics->camera3d);
     // Draw Ground
     DrawModel(graphics->groundModel_, graphics->groundModelpos_, 1., WHITE);
-    // Draw Robots
-    for (auto [rid, robot] : robots_)
+    // Draw Robots and Lines between masters and slaves
+    for (auto &[rid, robot] : robots_)
+    {
         robot->draw();
+        if (!robot->isMaster_)
+        {                                                        // Correct member variable name
+            auto master_robot = robots_.find(robot->master_id_); // Correct member variable name
+            if (master_robot != robots_.end())
+            {
+                // Cast positions to float explicitly
+                Vector3 slave_position = {
+                    static_cast<float>(robot->position_(0)),
+                    static_cast<float>(robot->position_(2)),
+                    static_cast<float>(robot->position_(1))};
+                Vector3 master_position = {
+                    static_cast<float>(master_robot->second->position_(0)),
+                    static_cast<float>(master_robot->second->position_(2)),
+                    static_cast<float>(master_robot->second->position_(1))};
+                DrawLine3D(slave_position, master_position, DARKGRAY);
+            }
+        }
+    }
     EndMode3D();
     draw_info(clock_);
     EndDrawing();
-};
+}
 
 /*******************************************************************************/
 // Timestep loop of simulator.

Commit: 669b81a86b4b13f3d45eb80b46c6cc0372dffab6
------------------------------------
commit 669b81a86b4b13f3d45eb80b46c6cc0372dffab6
Author: Safwan Chowdhury <safwanrija@yahoo.co.uk>
Date:   Fri Apr 26 01:57:06 2024 +0100

    Refactor robot creation logic in Simulator.cpp to include master-slave relationship

 inc/Robot.h       |  66 ++++++++++----------
 src/Robot.cpp     | 182 ++++++++++++++++++++++++++++++++----------------------
 src/Simulator.cpp |  11 ++--
 3 files changed, 149 insertions(+), 110 deletions(-)
diff --git a/inc/Robot.h b/inc/Robot.h
index 569e0ae..e95c65a 100644
--- a/inc/Robot.h
+++ b/inc/Robot.h
@@ -23,70 +23,70 @@ extern Globals globals;
 //      - Colour
 // This is a derived class from the FactorGraph class
 /***************************************************************************/
-class Robot : public FactorGraph {
+class Robot : public FactorGraph
+{
 public:
     // Constructor
-    Robot(Simulator* sim,
+    Robot(Simulator *sim,
           int rid,
           std::deque<Eigen::VectorXd> waypoints,
           float size,
-          Color color);
+          Color color,
+          bool isMaster,
+          int master_id);
     ~Robot();
 
-
-    Simulator* sim_;                            // Pointer to the simulator
-    int rid_ = 0;                               // Robot id
-    std::deque<Eigen::VectorXd> waypoints_{};   // Dequeue of waypoints (whenever the robot reaches a point, it is popped off the front of the dequeue)
-    float robot_radius_ = 1.;                   // Robot radius
-    Color color_ = DARKGREEN;                   // Colour of robot
-
-    int num_variables_;                         // Number of variables in the planned path (assumed to be the same for all robots)
-    std::vector<int> connected_r_ids_{};        // List of robot ids that are currently connected via inter-robot factors to this robot
-    std::vector<int> neighbours_{};             // List of robot ids that are within comms radius of this robot
-    Image* p_obstacleImage;                     // Pointer to image representing the obstacles in the environment
-    float height_3D_ = 0.f;                     // Height out of plane (for 3d visualisation only)
-    Eigen::VectorXd position_;                  // Position of the robot (equivalent to taking the [x,y] of the current state of the robot)
+    Simulator *sim_;                          // Pointer to the simulator
+    int rid_ = 0;                             // Robot id
+    std::deque<Eigen::VectorXd> waypoints_{}; // Dequeue of waypoints (whenever the robot reaches a point, it is popped off the front of the dequeue)
+    float robot_radius_ = 1.;                 // Robot radius
+    Color color_ = DARKGREEN;                 // Colour of robot
+    bool isMaster_ = false;                   // True if the robot is a master, false if it is a slave
+    int master_id_ = -1;                      // The id of the master robot this robot is connected to
+
+    int num_variables_;                  // Number of variables in the planned path (assumed to be the same for all robots)
+    std::vector<int> connected_r_ids_{}; // List of robot ids that are currently connected via inter-robot factors to this robot
+    std::vector<int> neighbours_{};      // List of robot ids that are within comms radius of this robot
+    Image *p_obstacleImage;              // Pointer to image representing the obstacles in the environment
+    float height_3D_ = 0.f;              // Height out of plane (for 3d visualisation only)
+    Eigen::VectorXd position_;           // Position of the robot (equivalent to taking the [x,y] of the current state of the robot)
 
     /****************************************/
-    //Functions
+    // Functions
     /****************************************/
     /* Change the prior of the Current state */
     void updateCurrent();
 
-    /* Change the prior of the Horizon state */    
+    /* Change the prior of the Horizon state */
     void updateHorizon();
 
     /***************************************************************************************************/
-    // For new neighbours of a robot, create inter-robot factors if they don't exist. 
+    // For new neighbours of a robot, create inter-robot factors if they don't exist.
     // Delete existing inter-robot factors for faraway robots
-    /***************************************************************************************************/    
+    /***************************************************************************************************/
     void updateInterrobotFactors();
     void createInterrobotFactors(std::shared_ptr<Robot> other_robot);
-    void deleteInterrobotFactors(std::shared_ptr<Robot> other_robot);  
-
+    void deleteInterrobotFactors(std::shared_ptr<Robot> other_robot);
 
-    /***************************************************************************************************/    
+    /***************************************************************************************************/
     // Drawing function
-    /***************************************************************************************************/    
+    /***************************************************************************************************/
     void draw();
 
     /*******************************************************************************************/
     // Function for determining the timesteps at which variables in the planned path are placed.
-    /*******************************************************************************************/   
+    /*******************************************************************************************/
     std::vector<int> getVariableTimesteps(int H, int M);
 
-
-    /*******************************************************************************************/   
+    /*******************************************************************************************/
     // Access operator to get a pointer to a variable from the robot.
-    /*******************************************************************************************/   
-    std::shared_ptr<Variable>& operator[] (const int& v_id){
+    /*******************************************************************************************/
+    std::shared_ptr<Variable> &operator[](const int &v_id)
+    {
         int n = variables_.size();
         int search_vid = ((n + v_id) % n + n) % n;
         auto it = variables_.begin();
         std::advance(it, search_vid);
         return it->second;
-    }    
-
-
+    }
 };
-
diff --git a/src/Robot.cpp b/src/Robot.cpp
index 34876b1..555c09a 100644
--- a/src/Robot.cpp
+++ b/src/Robot.cpp
@@ -12,26 +12,29 @@
 //      - Robot radius
 //      - Colour
 /***************************************************************************/
-Robot::Robot(Simulator* sim,
+Robot::Robot(Simulator *sim,
              int rid,
              std::deque<Eigen::VectorXd> waypoints,
              float size,
-             Color color) : FactorGraph{sim->next_rid_},
-             sim_(sim), rid_(rid),
-             waypoints_(waypoints),
-             robot_radius_(size), color_(color) {
+             Color color,
+             bool isMaster,
+             int master_id) : FactorGraph{sim->next_rid_},
+                              sim_(sim), rid_(rid),
+                              waypoints_(waypoints),
+                              robot_radius_(size), color_(color), isMaster_(isMaster), master_id_(master_id)
+{
 
-    height_3D_ = robot_radius_;     // Height out of plane for 3d visualisation only
+    height_3D_ = robot_radius_; // Height out of plane for 3d visualisation only
 
     // Robot will always set its horizon state to move towards the next waypoint.
     // Once this waypoint has been reached, it pops it from the waypoints
     Eigen::VectorXd start = position_ = waypoints_[0];
-    waypoints_.pop_front();                             
-    auto goal = (waypoints_.size()>0) ? waypoints_[0] : start;
+    waypoints_.pop_front();
+    auto goal = (waypoints_.size() > 0) ? waypoints_[0] : start;
 
     // Initialise the horzion in the direction of the goal, at a distance T_HORIZON * MAX_SPEED from the start.
     Eigen::VectorXd start2goal = goal - start;
-    Eigen::VectorXd horizon = start + std::min(start2goal.norm(), 1.*globals.T_HORIZON*globals.MAX_SPEED)*start2goal.normalized();
+    Eigen::VectorXd horizon = start + std::min(start2goal.norm(), 1. * globals.T_HORIZON * globals.MAX_SPEED) * start2goal.normalized();
 
     // Variables representing the planned path are at timesteps which increase in spacing.
     // eg. (so that a span of 10 timesteps as a planning horizon can be represented by much fewer variables)
@@ -41,16 +44,20 @@ Robot::Robot(Simulator* sim,
     /***************************************************************************/
     /* Create Variables with fixed pose priors on start and horizon variables. */
     /***************************************************************************/
-    Color var_color = color_; double sigma; int n = globals.N_DOFS;
-    Eigen::VectorXd mu(n); Eigen::VectorXd sigma_list(n); 
-    for (int i = 0; i < num_variables_; i++){
+    Color var_color = color_;
+    double sigma;
+    int n = globals.N_DOFS;
+    Eigen::VectorXd mu(n);
+    Eigen::VectorXd sigma_list(n);
+    for (int i = 0; i < num_variables_; i++)
+    {
         // Set initial mu and covariance of variable interpolated between start and horizon
-        mu = start + (horizon - start) * (float)(variable_timesteps[i]/(float)variable_timesteps.back());
+        mu = start + (horizon - start) * (float)(variable_timesteps[i] / (float)variable_timesteps.back());
         // Start and Horizon state variables should be 'fixed' during optimisation at a timestep
-        sigma = (i==0 || i==num_variables_-1) ? globals.SIGMA_POSE_FIXED : 0.;
+        sigma = (i == 0 || i == num_variables_ - 1) ? globals.SIGMA_POSE_FIXED : 0.;
         sigma_list.setConstant(sigma);
-        
-        // Create variable and add to robot's factor graph 
+
+        // Create variable and add to robot's factor graph
         auto variable = std::make_shared<Variable>(sim->next_vid_++, rid_, mu, sigma_list, robot_radius_, n);
         variables_[variable->key_] = variable;
     }
@@ -58,92 +65,102 @@ Robot::Robot(Simulator* sim,
     /***************************************************************************/
     /* Create Dynamics factors between variables */
     /***************************************************************************/
-    for (int i = 0; i < num_variables_-1; i++)
+    for (int i = 0; i < num_variables_ - 1; i++)
     {
         // T0 is the timestep between the current state and the first planned state.
         float delta_t = globals.T0 * (variable_timesteps[i + 1] - variable_timesteps[i]);
-        std::vector<std::shared_ptr<Variable>> variables {getVar(i), getVar(i+1)};
+        std::vector<std::shared_ptr<Variable>> variables{getVar(i), getVar(i + 1)};
         auto factor = std::make_shared<DynamicsFactor>(sim->next_fid_++, rid_, variables, globals.SIGMA_FACTOR_DYNAMICS, Eigen::VectorXd::Zero(globals.N_DOFS), delta_t);
-        
+
         // Add this factor to the variable's list of adjacent factors, as well as to the robot's list of factors
-        for (auto var : factor->variables_) var->add_factor(factor);
+        for (auto var : factor->variables_)
+            var->add_factor(factor);
         factors_[factor->key_] = factor;
     }
 
     /***************************************************************************/
     // Create Obstacle factors for all variables excluding start, excluding horizon
     /***************************************************************************/
-    for (int i = 1; i < num_variables_-1; i++)
+    for (int i = 1; i < num_variables_ - 1; i++)
     {
         std::vector<std::shared_ptr<Variable>> variables{getVar(i)};
         auto fac_obs = std::make_shared<ObstacleFactor>(sim, sim->next_fid_++, rid_, variables, globals.SIGMA_FACTOR_OBSTACLE, Eigen::VectorXd::Zero(1), &(sim_->obstacleImg));
 
         // Add this factor to the variable's list of adjacent factors, as well as to the robot's list of factors
-        for (auto var : fac_obs->variables_) var->add_factor(fac_obs);
+        for (auto var : fac_obs->variables_)
+            var->add_factor(fac_obs);
         this->factors_[fac_obs->key_] = fac_obs;
     }
-
 };
 
 /***************************************************************************************************/
 /* Destructor */
 /***************************************************************************************************/
-Robot::~Robot(){
+Robot::~Robot()
+{
 }
 
 /***************************************************************************************************/
 /* Change the prior of the Current state */
 /***************************************************************************************************/
-void Robot::updateCurrent(){
+void Robot::updateCurrent()
+{
     // Move plan: move plan current state by plan increment
     Eigen::VectorXd increment = ((*this)[1]->mu_ - (*this)[0]->mu_) * globals.TIMESTEP / globals.T0;
     // In GBP we do this by modifying the prior on the variable
     getVar(0)->change_variable_prior(getVar(0)->mu_ + increment);
     // Real pose update
     position_ = position_ + increment;
-
 };
 
 /***************************************************************************************************/
 /* Change the prior of the Horizon state */
 /***************************************************************************************************/
-void Robot::updateHorizon(){
+void Robot::updateHorizon()
+{
     // Horizon state moves towards the next waypoint.
     // The Horizon state's velocity is capped at MAX_SPEED
-    auto horizon = getVar(-1);      // get horizon state variable
-    Eigen::VectorXd dist_horz_to_goal = waypoints_.front()({0,1}) - horizon->mu_({0,1});                        
+    auto horizon = getVar(-1); // get horizon state variable
+    Eigen::VectorXd dist_horz_to_goal = waypoints_.front()({0, 1}) - horizon->mu_({0, 1});
     Eigen::VectorXd new_vel = dist_horz_to_goal.normalized() * std::min((double)globals.MAX_SPEED, dist_horz_to_goal.norm());
-    Eigen::VectorXd new_pos = horizon->mu_({0,1}) + new_vel*globals.TIMESTEP;
-    
+    Eigen::VectorXd new_pos = horizon->mu_({0, 1}) + new_vel * globals.TIMESTEP;
+
     // Update horizon state with new pos and vel
     horizon->mu_ << new_pos, new_vel;
     horizon->change_variable_prior(horizon->mu_);
 
     // If the horizon has reached the waypoint, pop that waypoint from the waypoints.
     // Could add other waypoint behaviours here (maybe they might move, or change randomly).
-    if (dist_horz_to_goal.norm() < robot_radius_){
-        if (waypoints_.size()>1) waypoints_.pop_front();
+    if (dist_horz_to_goal.norm() < robot_radius_)
+    {
+        if (waypoints_.size() > 1)
+            waypoints_.pop_front();
     }
 }
 
-
 /***************************************************************************************************/
-// For new neighbours of a robot, create inter-robot factors if they don't exist. 
+// For new neighbours of a robot, create inter-robot factors if they don't exist.
 // Delete existing inter-robot factors for faraway robots
 /***************************************************************************************************/
-void Robot::updateInterrobotFactors(){
-    
+void Robot::updateInterrobotFactors()
+{
+
     // Search through currently connected rids. If any are not in neighbours, delete interrobot factors.
-    for (auto rid : connected_r_ids_){
-        if (std::find(neighbours_.begin(), neighbours_.end(), rid)==neighbours_.end()){
+    for (auto rid : connected_r_ids_)
+    {
+        if (std::find(neighbours_.begin(), neighbours_.end(), rid) == neighbours_.end())
+        {
             deleteInterrobotFactors(sim_->robots_.at(rid));
         };
     }
     // Search through neighbours. If any are not in currently connected rids, create interrobot factors.
-    for (auto rid : neighbours_){
-        if (std::find(connected_r_ids_.begin(), connected_r_ids_.end(), rid)==connected_r_ids_.end()){
+    for (auto rid : neighbours_)
+    {
+        if (std::find(connected_r_ids_.begin(), connected_r_ids_.end(), rid) == connected_r_ids_.end())
+        {
             createInterrobotFactors(sim_->robots_.at(rid));
-            if (!sim_->symmetric_factors) sim_->robots_.at(rid)->connected_r_ids_.push_back(rid_);
+            if (!sim_->symmetric_factors)
+                sim_->robots_.at(rid)->connected_r_ids_.push_back(rid_);
         };
     }
 }
@@ -154,16 +171,18 @@ void Robot::updateInterrobotFactors(){
 void Robot::createInterrobotFactors(std::shared_ptr<Robot> other_robot)
 {
     // Create Interrobot factors for all timesteps excluding current state
-    for (int i = 1; i < num_variables_; i++){
+    for (int i = 1; i < num_variables_; i++)
+    {
         // Get variables
         std::vector<std::shared_ptr<Variable>> variables{getVar(i), other_robot->getVar(i)};
 
         // Create the inter-robot factor
         Eigen::VectorXd z = Eigen::VectorXd::Zero(variables.front()->n_dofs_);
-        auto factor = std::make_shared<InterrobotFactor>(sim_->next_fid_++, this->rid_, variables, globals.SIGMA_FACTOR_INTERROBOT, z, 0.5*(this->robot_radius_ + other_robot->robot_radius_));
+        auto factor = std::make_shared<InterrobotFactor>(sim_->next_fid_++, this->rid_, variables, globals.SIGMA_FACTOR_INTERROBOT, z, 0.5 * (this->robot_radius_ + other_robot->robot_radius_));
         factor->other_rid_ = other_robot->rid_;
         // Add factor the the variable's list of factors, as well as to the robot's list of factors
-        for (auto var : factor->variables_) var->add_factor(factor);
+        for (auto var : factor->variables_)
+            var->add_factor(factor);
         this->factors_[factor->key_] = factor;
     }
 
@@ -177,54 +196,68 @@ void Robot::createInterrobotFactors(std::shared_ptr<Robot> other_robot)
 void Robot::deleteInterrobotFactors(std::shared_ptr<Robot> other_robot)
 {
     std::vector<Key> facs_to_delete{};
-    for (auto& [f_key, fac] : this->factors_){
-        if (fac->other_rid_ != other_robot->rid_) continue;
+    for (auto &[f_key, fac] : this->factors_)
+    {
+        if (fac->other_rid_ != other_robot->rid_)
+            continue;
 
         // Only get here if factor is connected to a variable in the other_robot
-        for (auto& var : fac->variables_){ 
+        for (auto &var : fac->variables_)
+        {
             var->delete_factor(f_key);
             facs_to_delete.push_back(f_key);
         }
     }
-    for (auto f_key : facs_to_delete) this->factors_.erase(f_key);
+    for (auto f_key : facs_to_delete)
+        this->factors_.erase(f_key);
 
     // Remove other robot from current robot's connected rids
     auto it = std::find(connected_r_ids_.begin(), connected_r_ids_.end(), other_robot->rid_);
-    if (it != connected_r_ids_.end()){
+    if (it != connected_r_ids_.end())
+    {
         connected_r_ids_.erase(it);
     }
-
 };
 
 /***************************************************************************************************/
 // Drawing functions for the robot.
 // We deal with a 2d problem, so the out-of-plane height is set to height_3D_.
 /***************************************************************************************************/
-void Robot::draw(){
+void Robot::draw()
+{
     Color col = (interrobot_comms_active_) ? color_ : GRAY;
     // Draw planned path
-    if (globals.DRAW_PATH){
+    if (globals.DRAW_PATH)
+    {
         static int debug = 0;
-        for (auto [vid, variable] : variables_){
-            if (!variable->valid_) continue;
-            DrawSphere(Vector3{(float)variable->mu_(0), height_3D_, (float)variable->mu_(1)}, 0.5*robot_radius_, ColorAlpha(col, 0.5));
+        for (auto [vid, variable] : variables_)
+        {
+            if (!variable->valid_)
+                continue;
+            DrawSphere(Vector3{(float)variable->mu_(0), height_3D_, (float)variable->mu_(1)}, 0.5 * robot_radius_, ColorAlpha(col, 0.5));
         }
-        for (auto [fid, factor] : factors_) factor->draw();
-    }     
+        for (auto [fid, factor] : factors_)
+            factor->draw();
+    }
     // Draw connected robots
-    if (globals.DRAW_INTERROBOT){
-        for (auto rid : connected_r_ids_){
-            if (!interrobot_comms_active_ || !sim_->robots_.at(rid)->interrobot_comms_active_) continue;
+    if (globals.DRAW_INTERROBOT)
+    {
+        for (auto rid : connected_r_ids_)
+        {
+            if (!interrobot_comms_active_ || !sim_->robots_.at(rid)->interrobot_comms_active_)
+                continue;
             DrawCylinderEx(Vector3{(float)position_(0), height_3D_, (float)position_(1)},
-                            Vector3{(float)(*sim_->robots_.at(rid))[0]->mu_(0), sim_->robots_.at(rid)->height_3D_, (float)(*sim_->robots_.at(rid))[0]->mu_(1)}, 
-                            0.1, 0.1, 4, BLACK);
+                           Vector3{(float)(*sim_->robots_.at(rid))[0]->mu_(0), sim_->robots_.at(rid)->height_3D_, (float)(*sim_->robots_.at(rid))[0]->mu_(1)},
+                           0.1, 0.1, 4, BLACK);
         }
     }
 
     // Draw the waypoints of the robot
-    if (globals.DRAW_WAYPOINTS){
-        for (int wp_idx=0; wp_idx<waypoints_.size(); wp_idx++){
-            DrawCubeV(Vector3{(float)waypoints_[wp_idx](0), height_3D_, (float)waypoints_[wp_idx](1)}, Vector3{1.f*robot_radius_,1.f*robot_radius_,1.f*robot_radius_}, col);
+    if (globals.DRAW_WAYPOINTS)
+    {
+        for (int wp_idx = 0; wp_idx < waypoints_.size(); wp_idx++)
+        {
+            DrawCubeV(Vector3{(float)waypoints_[wp_idx](0), height_3D_, (float)waypoints_[wp_idx](1)}, Vector3{1.f * robot_radius_, 1.f * robot_radius_, 1.f * robot_radius_}, col);
         }
     }
     // Draw the actual position of the robot. This uses the robotModel defined in Graphics.cpp, others can be used.
@@ -234,11 +267,12 @@ void Robot::draw(){
 /*******************************************************************************************/
 // Function for determining the timesteps at which variables in the planned path are placed.
 /*******************************************************************************************/
-std::vector<int> Robot::getVariableTimesteps(int lookahead_horizon, int lookahead_multiple){
+std::vector<int> Robot::getVariableTimesteps(int lookahead_horizon, int lookahead_multiple)
+{
     // For a lookahead_multiple of 3, variables are spaced at timesteps:
     // Timesteps
     // 0,    1, 2, 3,    5, 7, 9,    12, 15, 18, ...
-    // 
+    //
     // eg. variables are in groups of size lookahead_multiple.
     // the spacing within a group increases by one each time (1 for the first group, 2 for the second ...)
     // Seems convoluted, but the reasoning was:
@@ -246,12 +280,14 @@ std::vector<int> Robot::getVariableTimesteps(int lookahead_horizon, int lookahea
     //      the first few variables should be close together in time
     //      the variables should all be at integer timesteps, but the spacing should sort of increase exponentially.
     std::vector<int> var_list{};
-    int N = 1 + int(0.5*(-1 + sqrt(1 + 8*(float)lookahead_horizon/(float)lookahead_multiple)));
+    int N = 1 + int(0.5 * (-1 + sqrt(1 + 8 * (float)lookahead_horizon / (float)lookahead_multiple)));
 
-    for (int i=0; i<lookahead_multiple*(N+1); i++){
-        int section = int(i/lookahead_multiple);
-        int f = (i - section*lookahead_multiple + lookahead_multiple/2.*section)*(section+1);
-        if (f>=lookahead_horizon){
+    for (int i = 0; i < lookahead_multiple * (N + 1); i++)
+    {
+        int section = int(i / lookahead_multiple);
+        int f = (i - section * lookahead_multiple + lookahead_multiple / 2. * section) * (section + 1);
+        if (f >= lookahead_horizon)
+        {
             var_list.push_back(lookahead_horizon);
             break;
         }
diff --git a/src/Simulator.cpp b/src/Simulator.cpp
index 43f0899..f9318c6 100644
--- a/src/Simulator.cpp
+++ b/src/Simulator.cpp
@@ -259,8 +259,11 @@ void Simulator::createOrDeleteRobots()
             // Define robot radius and colour here.
             float robot_radius = globals.ROBOT_RADIUS;
             // If i is even, robot is red, else blue.
-            Color robot_color = (i % 2 == 0) ? DARKBROWN : DARKBLUE;
-            robots_to_create.push_back(std::make_shared<Robot>(this, next_rid_++, waypoints, robot_radius, robot_color));
+            bool isMaster = (next_rid_ % 2 == 0); // for example, even ids are masters
+            Color robot_color = isMaster ? DARKBROWN : DARKBLUE;
+            int master_id = isMaster ? next_rid_ : next_rid_ - 1; // for example, each slave has the previous robot as master
+
+            robots_to_create.push_back(std::make_shared<Robot>(this, next_rid_++, waypoints, robot_radius, robot_color, isMaster, master_id));
         }
     }
     else if (globals.FORMATION == "junction")
@@ -285,7 +288,7 @@ void Simulator::createOrDeleteRobots()
             std::deque<Eigen::VectorXd> waypoints{starting, ending};
             float robot_radius = globals.ROBOT_RADIUS;
             Color robot_color = DARKGREEN;
-            robots_to_create.push_back(std::make_shared<Robot>(this, next_rid_++, waypoints, robot_radius, robot_color));
+            robots_to_create.push_back(std::make_shared<Robot>(this, next_rid_++, waypoints, robot_radius, robot_color, false, -1));
         }
 
         // Delete robots if out of bounds
@@ -323,7 +326,7 @@ void Simulator::createOrDeleteRobots()
             std::deque<Eigen::VectorXd> waypoints{starting, turning, ending};
             float robot_radius = globals.ROBOT_RADIUS;
             Color robot_color = ColorFromHSV(turn * 120., 1., 0.75);
-            robots_to_create.push_back(std::make_shared<Robot>(this, next_rid_++, waypoints, robot_radius, robot_color));
+            robots_to_create.push_back(std::make_shared<Robot>(this, next_rid_++, waypoints, robot_radius, robot_color, false, -1));
         }
 
         // Delete robots if out of bounds

